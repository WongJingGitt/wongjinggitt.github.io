<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Markdown转换工具</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- PDF/Image Export Libs -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- *** NEW DOCX Export Lib *** -->
    <script src="https://unpkg.com/html-docx-js/dist/html-docx.js"></script>
    <!-- *** Removed old html-to-docx-ts script *** -->
    <!-- Highlight JS -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.css" integrity="sha512-jYtlOKxyOGJQxuHAR9h4PK04vh9HzaxI0dHVXx/kqICgw82nv3UpzWkaef+Fg8g4XJEvf/W+sPOnaeYQp5SRaQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* --- [All Existing CSS Styles Remain the Same] --- */
         :root {
            --bg-color: #f8f9fa;
            --preview-bg: #ffffff;
            --border-color: #e1e4e8;
            --text-color: #24292e;
            --secondary-text-color: #6a737d;
            --primary-color: #0366d6;
            --primary-hover-color: #0056b3;
            --danger-color: #d73a49;
            --danger-hover-color: #cb2431;
            --modal-overlay-bg: rgba(0,0,0,0.6);
            --modal-content-bg: #ffffff;
        }

        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            overflow: hidden; /* Prevent body scrollbars */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .container {
            padding: 2rem;
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 2rem;
            margin: 0 auto;
            height: calc(100vh - 1rem); /* Full height minus padding */
            box-sizing: border-box; /* Include padding in height calculation */
        }

        .editor-box, .preview-box {
            background: var(--preview-bg);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow: hidden; /* Prevent box itself from overflowing */
            min-width: 0; /* Fix Issue 2: Allow grid item to shrink */
        }

        .markdown-body {
            background: var(--preview-bg) !important;
            padding: 1.5rem !important;
            width: 100%; /* Use full width */
            height: 100%; /* Use full height */
            box-sizing: border-box; /* Include padding in dimensions */
            overflow: auto; /* Use combined overflow property */
        }

        .title-toolbar {
            display: flex;
            gap: 0.75rem; /* Slightly reduced gap */
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        select, button, input[type="search"] { /* Added search input */
            padding: 0.5rem 1rem;
            border-radius: 6px; /* Slightly rounder */
            border: 1px solid var(--border-color);
            background: white;
            font-size: 0.9em; /* Consistent font size */
            box-sizing: border-box;
        }
        button {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        button:hover {
             border-color: #c6cbd1;
             background-color: #f6f8fa;
        }
        button:active {
             background-color: #f3f4f6;
             border-color: #c6cbd1;
             box-shadow: inset 0 1px 0 rgba(225,228,232,0.2);
        }


        button.primary {
            background: var(--primary-color);
            color: white;
            border: 1px solid var(--primary-color); /* Fixed border color */
        }

        button.primary:hover {
            background: var(--primary-hover-color);
            border-color: var(--primary-hover-color);
        }

        button.danger {
            background-color: var(--danger-color);
            color: white;
            border-color: var(--danger-color);
         }
         button.danger:hover {
            background-color: var(--danger-hover-color);
            border-color: var(--danger-hover-color);
         }
         button.small {
            padding: 0.3rem 0.8rem;
            font-size: 0.8em;
         }

         .notice {
            color: var(--secondary-text-color);
            font-size: 0.9em;
            margin-top: 0; /* Adjusted margin */
            margin-left: auto; /* Push notice to the right if space allows */
        }
        .card-title {
            padding: 10px 0; /* Adjusted padding */
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            flex-shrink: 0; /* Prevent title from shrinking */
            box-sizing: border-box;
            flex-wrap: wrap; /* Allow wrapping */
            gap: 10px; /* Add gap for wrapped items */
            border-bottom: 1px solid var(--border-color); /* Add subtle separator */
            margin-bottom: 0.5rem; /* Space below title */
        }
        .card-body {
            flex-grow: 1; /* Allow body to take remaining space */
            overflow: hidden; /* Important: Let children handle scroll */
            display: flex; /* Use flex for inner content */
            flex-direction: column; /* Stack children vertically */
        }
        .text-title {
            font-size: 1.25em; /* Adjusted size */
            font-weight: 600; /* Bolder */
            margin-right: auto; /* Push buttons to the right */
            white-space: nowrap; /* Prevent title breaking */
        }
        .title-button-group {
             display: flex;
             gap: 0.5rem;
             align-items: center;
             margin-left: 1rem; /* Space between title and buttons */
        }
		.title-button-item { /* Applied to buttons */
			height: 35px;
			min-width: 75px;
			display: inline-flex; /* Use inline-flex for button content */
			align-items: center;
			justify-content: center; /* Center content */
            gap: 0.4em; /* Space between icon and text */
            padding: 0.5rem 0.8rem; /* Adjust padding */
            white-space: nowrap; /* Prevent text wrapping */
		}
        .icon-button svg {
            vertical-align: middle;
        }
        .editor {
            width: 100%;
            font-family: 'Fira Code', 'Consolas', monospace;
            border-radius: 6px; /* Match button radius */
            overflow: hidden; /* Keep this */
            display: flex; /* Fix Issue 1: Use flex */
            flex-direction: column; /* Fix Issue 1: Stack toolbar and textarea */
            flex-grow: 1; /* Make editor container fill card-body */
            border: 1px solid var(--border-color); /* Use variable */
            background: #fafafa; /* Background for the whole editor area */
        }

        #editor { /* Textarea */
            width: 100%; /* Use full width */
            flex-grow: 1; /* Fix Issue 1: Allow textarea to fill space */
            padding: 15px; /* Adjusted padding */
            font-size: 14px;
            line-height: 1.6;
            border: none;
            background: transparent; /* Inherit background or set specific */
            resize: none;
            tab-size: 4;
            overflow-y: auto; /* Keep vertical scroll */
            box-sizing: border-box; /* Include padding in dimensions */
        }

        #editor:focus {
            outline: none;
        }

        .toolbar {
            padding: 8px 15px; /* Match textarea horizontal padding */
            background: #f6f8fa; /* Lighter toolbar */
            border-bottom: 1px solid var(--border-color); /* Use variable */
            font-size: 0.85em; /* Slightly smaller */
            color: var(--secondary-text-color); /* Use variable */
            flex-shrink: 0; /* Fix Issue 1: Prevent toolbar from shrinking */
            box-sizing: border-box;
            width: 100%;
            user-select: none; /* Prevent text selection */
        }

        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: var(--modal-overlay-bg); /* Black w/ opacity */
            backdrop-filter: blur(3px); /* Optional blur effect */
        }

        .modal-content {
            background-color: var(--modal-content-bg);
            margin: 8% auto; /* Reduced top margin slightly */
            padding: 25px;
            border: 1px solid var(--border-color);
            width: 85%; /* Slightly wider */
            max-width: 650px; /* Slightly wider max */
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            position: relative; /* For close button positioning */
            animation: fadeIn 0.3s ease-out;
            display: flex; /* Use flex for layout */
            flex-direction: column; /* Stack vertically */
            gap: 1rem; /* Space between elements */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.8rem;
        }

        .modal-close-btn {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            line-height: 1;
            background: none;
            border: none;
            padding: 0 5px; /* Add some clickable area */
            cursor: pointer;
        }

        .modal-close-btn:hover,
        .modal-close-btn:focus {
            color: black;
            text-decoration: none;
        }

        .modal h2 {
            margin: 0; /* Reset margin */
            font-weight: 600;
            font-size: 1.3em;
        }
        .modal-toolbar { /* Container for search and save new button */
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping */
        }
        #searchInput, #historySearchInput { /* Apply to both search inputs */
            flex-grow: 1; /* Allow search to take available space */
            min-width: 200px; /* Minimum width */
        }
        #saveNewButton {
             display: none; /* Hidden by default, shown via JS */
        }

        .saved-item-list, .history-item-list { /* Style both lists */
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 50vh; /* Increased max height */
            overflow-y: auto;
            border: 1px solid var(--border-color); /* Add border around list */
            border-radius: 6px;
        }

        .saved-item, .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px; /* Adjust padding */
            border-bottom: 1px solid #eee;
            transition: background-color 0.15s ease-in-out;
            gap: 10px; /* Space between info and actions */
        }
        .saved-item:last-child, .history-item:last-child {
            border-bottom: none;
        }
        .saved-item:hover, .history-item:hover {
            background-color: #f6f8fa;
        }

        .item-info {
            display: flex;
            flex-direction: column;
            gap: 3px; /* Increased gap */
            flex-grow: 1; /* Allow info to take space */
            min-width: 0; /* Prevent overflow issues */
        }

        .item-name { /* Specific to saved items */
            font-weight: 500;
            color: var(--text-color);
            white-space: nowrap; /* Prevent wrapping */
            overflow: hidden; /* Hide overflow */
            text-overflow: ellipsis; /* Add ellipsis */
        }
        .item-content-preview { /* Specific to history items */
            font-size: 0.9em;
            color: var(--secondary-text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 350px; /* Limit preview width */
            display: inline-block; /* Needed for ellipsis */
        }

        .item-timestamp {
            font-size: 0.8em;
            color: var(--secondary-text-color);
        }
        .item-actions {
            display: flex;
            gap: 8px; /* Consistent gap */
            flex-shrink: 0; /* Prevent shrinking */
        }

        .no-items {
             text-align: center;
             color: var(--secondary-text-color);
             padding: 2rem 0;
             font-style: italic;
             border-bottom: none !important; /* Ensure no border */
             display: block !important; /* Ensure it takes full width */
        }
        .no-items:hover {
             background-color: transparent !important; /* No hover effect */
        }
        .toast-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            border-radius: 6px;
            z-index: 1050; /* Above modal overlay */
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            text-align: center;
            pointer-events: none; /* Prevent interaction */
        }
        .toast-message.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 编辑区 -->
        <div class="editor-box">
            <div class="card-title">
                <div class="text-title">Markdown 编辑器</div>
                <div class="title-button-group">
                    <button onclick="showLoadModal()" title="Load saved markdown" class="title-button-item icon-button">
						<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-download"><path d="M2.75 14A1.75 1.75 0 0 1 1 12.25v-2.5a.75.75 0 0 1 1.5 0v2.5c0 .138.112.25.25.25h10.5a.25.25 0 0 0 .25-.25v-2.5a.75.75 0 0 1 1.5 0v2.5A1.75 1.75 0 0 1 13.25 14Z M8 11.75a.75.75 0 0 1-.75-.75V1.5a.75.75 0 0 1 1.5 0v9.5a.75.75 0 0 1-.75.75Zm-4.28-4.28a.75.75 0 0 1 0-1.06l4.25-4.25a.75.75 0 0 1 1.06 0l4.25 4.25a.75.75 0 0 1-1.06 1.06L8.75 4.31V9.5a.75.75 0 0 1-1.5 0V4.31L3.78 7.47a.75.75 0 0 1-1.06 0Z"></path></svg>
						加载
					</button>
                    <button class="primary title-button-item icon-button" onclick="showSaveModal()" title="Save or update markdown">
						<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-file-directory-fill"><path d="M1.75 1A1.75 1.75 0 0 0 0 2.75v10.5C0 14.216.784 15 1.75 15h12.5A1.75 1.75 0 0 0 16 13.25v-8.5A1.75 1.75 0 0 0 14.25 3H7.5a.25.25 0 0 1-.2-.09L5.95 1.36A.75.75 0 0 0 5.41 1H1.75Z"></path></svg>
						保存
					</button>
                    <button onclick="showHistoryModal()" title="View edit history" class="title-button-item icon-button">
						<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-history"><path d="M1.643 3.143L.427 1.927A.25.25 0 0 0 0 2.104V5.75c0 .138.112.25.25.25h3.646a.25.25 0 0 0 .177-.427L2.715 4.215a6.5 6.5 0 1 1-1.18 4.458.75.75 0 1 0-1.493.154 8.001 8.001 0 1 0 1.6-5.684zM7.75 4a.75.75 0 0 1 .75.75v4.336l3.47 2.023a.75.75 0 0 1-.74 1.298l-3.75-2.165A.75.75 0 0 1 7 9.75V4.75a.75.75 0 0 1 .75-.75z"></path></svg>
						历史
					</button>
                    <button class="title-button-item" onclick="loadSample()" >加载示例</button>
                </div>
            </div>
            <div class="card-body">
                <div class="editor">
                    <div class="toolbar">Markdown Editor (Tab/Shift+Tab supported)</div>
                    <textarea id="editor" placeholder="Start typing markdown here..."></textarea>
                </div>
            </div>
        </div>

        <!-- 预览区 -->
        <div class="preview-box">
            <div  class="card-title">
                <div class="text-title">
                    实时预览
                </div>
                <div class="title-toolbar">
                    <select id="format">
                        <option value="image" selected>图片</option>
                        <option value="html">HTML</option>
                        <option value="pdf">PDF</option> <!-- Added PDF -->
                        <option value="docx">DOCX</option> <!-- Added DOCX -->
                    </select>
                    <button class="primary" onclick="exportFile(event)">导出文件</button> <!-- Pass event -->
                    <p class="notice">提示：生成图片/PDF可能需5-10秒</p> <!-- Updated notice -->
                </div>
            </div>
            <div class="card-body">
                <div class="markdown-body" id="preview"></div>
            </div>
        </div>
    </div>

     <!-- Load/Save Markdown Modal -->
    <div id="loadModal" class="modal">
        <div class="modal-content">
             <div class="modal-header">
                 <h2 id="modalTitle">加载已保存的 Markdown</h2>
                 <button class="modal-close-btn" onclick="hideLoadModal()" title="关闭">&times;</button>
             </div>
             <div class="modal-toolbar">
                <input type="search" id="searchInput" placeholder="按名称搜索..." oninput="filterSavedItems()">
                <button id="saveNewButton" class="primary" onclick="handleSaveNew()">另存为新...</button>
             </div>
            <ul id="savedItemList" class="saved-item-list">
                <!-- Items will be loaded here by JavaScript -->
                 <li class="no-items">没有找到已保存的文档。</li>
            </ul>
        </div>
    </div>

    <!-- Edit History Modal -->
    <div id="historyModal" class="modal">
        <div class="modal-content">
             <div class="modal-header">
                 <h2 id="historyModalTitle">编辑历史记录</h2>
                 <button class="modal-close-btn" onclick="hideHistoryModal()" title="关闭">&times;</button>
             </div>
             <!-- Optional: Add search for history if needed -->
             <!-- <div class="modal-toolbar">
                <input type="search" id="historySearchInput" placeholder="搜索历史记录..." oninput="filterHistoryItems()">
             </div> -->
            <ul id="historyItemList" class="history-item-list">
                <!-- History items will be loaded here -->
                 <li class="no-items">没有编辑历史记录。</li>
            </ul>
        </div>
    </div>

    <!-- 独立示例内容 -->
    <script id="sampleMarkdown" type="text/template">
# 现代化文档转换工具 (v2)

## 功能特性

- [x] ​**​实时HTML预览​**​
- [x] 多格式导出支持 (HTML, 图片, **PDF**, **DOCX**)
- [x] 专业样式渲染 (GitHub Markdown CSS + Highlight.js)
- [x] 内容本地存储 (IndexedDB) - 支持搜索、更新、删除
- [x] ​**​编辑历史记录​**​ (自动保存，上限50条)
- [ ] <span style="color: #A0A1A7;">更多功能敬请期待...</span>

```javascript
// 完整的代码示例 (JS)
function greet(name) {
    // Uses template literals
    return `Hello, ${name}! Welcome to the editor.`;
}
console.log(greet('Developer'));
// Expected Output: Hello, Developer! Welcome to the editor.

/* Multi-line comment test
   Still works! */
```

```python
# Python Code Block Example
import sys

def check_version():
  """Prints the Python version."""
  print(f"Python Version: {sys.version}")

if __name__ == "__main__":
  check_version()
```

## 使用指南

1.  在左侧 **编辑器** 中输入或粘贴Markdown文本。
2.  右侧将 **实时预览** 渲染后的效果。
3.  点击编辑器上方的 **保存** 按钮:
    *   在弹出窗口中点击 **另存为新...** 以创建新条目。
    *   点击列表中某一项旁的 **更新** 按钮以覆盖现有条目。
4.  点击编辑器上方的 **加载** 按钮:
    *   使用 **搜索框** 快速查找。
    *   点击列表中某一项旁的 **加载** 按钮将其内容填入编辑器。
    *   点击 **删除** 按钮移除条目。
5.  点击编辑器上方的 **历史** 按钮:
    *   查看自动保存的编辑记录 (最近优先)。
    *   点击 **恢复** 将该版本内容加载到编辑器。
    *   点击 **删除** 移除该条历史记录。
6.  在预览区上方选择 **导出格式** (HTML, 图片, PDF, DOCX)，然后点击 **导出文件** 下载。 *PDF导出将保留视觉样式，但文本不可选。DOCX会尝试转换结构和基本样式。*

> 专业的技术文档与演示解决方案，提供更完善的本地管理和追溯功能！

---

## 宽内容测试

### 表格

| Header 1 | Header 2 | Header 3 | Header 4 | Header 5 | Header 6 | Header 7 | Header 8 | Header 9 | Header 10 | Header 11 | Header 12 |
|---|---|---|---|---|---|---|---|---|---|---|---|
| Data 1 | Data 2 | Data 3 | Data 4 | Data 5 | Data 6 | Data 7 | Data 8 | Data 9 | Data 10 | Data 11 | Data 12 |
| Long Data Entry Cell Number One | Long Data Entry Cell Number Two | Long Data Entry Cell Number Three | Long Data Entry Cell Number Four | Long Data Entry Cell Number Five | Long Data Entry Cell Number Six | Long Data Entry Cell Number Seven | Long Data Entry Cell Number Eight | Long Data Entry Cell Number Nine | Long Data Entry Cell Number Ten | Long Data Entry Cell Number Eleven | Long Data Entry Cell Number Twelve |

### 长代码块

```text
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
```
    </script>

    <script>
        // --- Global Variables & Constants ---
        const editor = document.getElementById('editor');
        const preview = document.getElementById('preview');
        const sampleContent = document.getElementById('sampleMarkdown').textContent.trim(); // Keep this line
        const loadModal = document.getElementById('loadModal');
        const savedItemList = document.getElementById('savedItemList');
        const searchInput = document.getElementById('searchInput');
        const modalTitle = document.getElementById('modalTitle');
        const saveNewButton = document.getElementById('saveNewButton');
        const historyModal = document.getElementById('historyModal');
        const historyItemList = document.getElementById('historyItemList');

        const DB_NAME = 'markdownDB';
        const SAVED_STORE_NAME = 'savedMarkdown';
        const HISTORY_STORE_NAME = 'editHistory'; // New store name
        const HISTORY_LIMIT = 50; // Max number of history entries
        let db; // Database instance
        let historySaveTimeout; // Timeout for debounced history saving
        let lastSavedHistoryContent = null; // Track last saved history content to avoid duplicates
        let isSyncing = false; // For scroll sync


        // --- Toast Notification ---
		function showToast(message, duration = 3000) {
		    document.querySelectorAll('.toast-message').forEach(t => t.remove()); // Remove existing
            const toast = document.createElement('div');
            toast.textContent = message;
		    toast.className = 'toast-message';
		    document.body.appendChild(toast);
		    requestAnimationFrame(() => {
                requestAnimationFrame(() => { toast.classList.add('show'); }); // Ensure transition triggers
            });
		    setTimeout(() => {
		        toast.classList.remove('show');
		        toast.addEventListener('transitionend', () => toast.remove());
		    }, duration);
		}

        // --- Editor & Indentation Logic ---
        editor.addEventListener('keydown', (e) => {
            if (e.key === 'Tab' && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
                e.preventDefault(); handleIndentation('indent');
            } else if (e.key === 'Tab' && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
                e.preventDefault(); handleIndentation('unindent');
            }
        });
        function handleIndentation(action) { // Indentation logic remains the same
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const value = editor.value;
            const tab = '    ';

            if (start === end) {
                const lineStart = value.lastIndexOf('\n', start - 1) + 1;
                if (action === 'indent') {
                    editor.setRangeText(tab, start, start, 'end');
                } else {
                    const line = value.substring(lineStart, start);
                    if (line.startsWith(tab)) { editor.setRangeText('', lineStart, lineStart + tab.length, 'end'); }
                    else if (line.startsWith('\t')) { editor.setRangeText('', lineStart, lineStart + 1, 'end'); }
                    else {
                         const leadingSpaces = line.match(/^[ ]{1,4}/);
                         if (leadingSpaces) { editor.setRangeText('', lineStart, lineStart + leadingSpaces[0].length, 'end'); }
                    }
                }
            } else {
                const selectionLineStart = value.lastIndexOf('\n', start - 1) + 1;
                const textToModify = value.substring(selectionLineStart, end);
                let modifiedText = '';
                let lineShiftFirst = 0;
                const lines = textToModify.split('\n');
                lines.forEach((line, index) => {
                    let currentLineShift = 0;
                    if (action === 'indent') {
                        modifiedText += tab + line; currentLineShift = tab.length;
                    } else {
                        if (line.startsWith(tab)) { modifiedText += line.substring(tab.length); currentLineShift = -tab.length; }
                        else if (line.startsWith('\t')) { modifiedText += line.substring(1); currentLineShift = -1; }
                        else {
                             const leadingSpaces = line.match(/^[ ]{1,4}/);
                             if (leadingSpaces) { modifiedText += line.substring(leadingSpaces[0].length); currentLineShift = -leadingSpaces[0].length; }
                             else { modifiedText += line; }
                        }
                    }
                    if (index < lines.length - 1) { modifiedText += '\n'; }
                    if (index === 0) {
                         if (start > selectionLineStart) { lineShiftFirst = currentLineShift > 0 ? tab.length : Math.max(currentLineShift, -(start - selectionLineStart)); }
                         else { lineShiftFirst = currentLineShift; }
                    }
                });
                editor.setRangeText(modifiedText, selectionLineStart, end, 'select');
                const finalStart = Math.max(selectionLineStart, start + lineShiftFirst);
                const lengthDifference = modifiedText.length - textToModify.length;
                const finalEnd = end + lengthDifference;
                editor.setSelectionRange(finalStart, finalEnd);
            }
            triggerHistorySave();
        }

        // --- Core Editor and Preview Logic ---
        marked.setOptions({
            highlight: (code, lang) => {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                try {
                     if (language) { return hljs.highlight(code, { language, ignoreIllegals: true }).value; }
                } catch (e) { console.error(`Highlighting error for lang ${lang}:`, e); }
                try { return hljs.highlightAuto(code).value; }
                catch (autoError) {
                    console.error("Auto highlighting failed:", autoError);
                    const escapedCode = code.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    return `<pre><code class="hljs">${escapedCode}</code></pre>`;
                }
            },
            breaks: true, gfm: true
        });

        function loadSample() {
            editor.value = sampleContent;
            updatePreview();
            showToast("示例内容已加载");
            lastSavedHistoryContent = null; // Allow potential save of sample if user interacts further
        }

        function updatePreview() {
            try {
                 preview.innerHTML = marked.parse(editor.value);
                 hljs.highlightAll();
            } catch (e) {
                 console.error("Markdown Parsing Error:", e);
                 preview.innerHTML = `<p style="color: red;">Error parsing Markdown. Check console for details.</p>`;
            }
        }

        // --- Export Logic (Using html-docx-js) ---
        async function exportFile(event) {
            const format = document.getElementById('format').value;
            const markdownInput = editor.value;
            const previewElement = document.getElementById('preview');
            const exportButton = event.target;
            const originalButtonText = exportButton.textContent;
            exportButton.disabled = true;
            exportButton.textContent = '导出中...';

            // Ensure preview is up-to-date for export
            try {
                previewElement.innerHTML = marked.parse(markdownInput);
                hljs.highlightAll();
            } catch (e) {
                showToast(`Markdown 解析错误，无法导出: ${e.message}`);
                console.error("Markdown Parsing Error on Export:", e);
                exportButton.disabled = false;
                exportButton.textContent = originalButtonText;
                return;
            }

            // Use a temporary container for html2canvas to capture background/padding
            const captureContainer = document.createElement('div');
            captureContainer.className = 'markdown-body'; // Apply styling for capture
            Object.assign(captureContainer.style, {
                position: 'absolute', left: '-9999px', top: '0px',
                padding: '2rem', background: 'var(--preview-bg)', // Use computed styles later
                width: previewElement.scrollWidth + 'px', // Use scrollWidth
                minWidth: '600px', height: 'auto', overflow: 'visible',
                boxSizing: 'content-box'
            });
            // Clone the *preview* element, not the whole container, for content
            const clonedPreview = previewElement.cloneNode(true);
            captureContainer.appendChild(clonedPreview);
            document.body.appendChild(captureContainer);

            // Wait for styles and layout
            await new Promise(resolve => requestAnimationFrame(resolve));
            await new Promise(resolve => setTimeout(resolve, 150));

            try {
                switch(format) {
                    case 'image':
                    case 'pdf':
                        console.log(`Exporting as ${format.toUpperCase()}...`);
                        const scale = window.devicePixelRatio || 2;
                        // Capture the container div which includes padding and background
                        const canvas = await html2canvas(captureContainer, {
                            scale: scale, useCORS: true, logging: false, scrollX: 0, scrollY: 0,
                            windowWidth: captureContainer.scrollWidth,
                            windowHeight: captureContainer.scrollHeight,
                            backgroundColor: getComputedStyle(captureContainer).backgroundColor // Get actual bg
                        });
                        console.log('Canvas generated');

                        if (format === 'image') {
                            triggerDownload(canvas.toDataURL('image/png'), 'export.png');
                            showToast('图片导出成功！');
                        } else { // PDF Export
                            const { jsPDF } = window.jspdf;
                            const imgData = canvas.toDataURL('image/png');
                            const imgProps = { width: canvas.width / scale, height: canvas.height / scale };
                            const pdf = new jsPDF({
                                orientation: imgProps.width > imgProps.height ? 'l' : 'p',
                                unit: 'px',
                                format: [imgProps.width, imgProps.height]
                            });
                            const pdfWidth = pdf.internal.pageSize.getWidth();
                            const pdfHeight = pdf.internal.pageSize.getHeight();
                            const ratio = Math.min(pdfWidth / imgProps.width, pdfHeight / imgProps.height);
                            const imgPdfWidth = imgProps.width * ratio;
                            const imgPdfHeight = imgProps.height * ratio;
                            const x = (pdfWidth - imgPdfWidth) / 2;
                            const y = 0;
                            pdf.addImage(imgData, 'PNG', x, y, imgPdfWidth, imgPdfHeight);
                            pdf.save('export.pdf');
                            showToast('PDF导出成功！(作为单页图片)');
                        }
                        break;

                    case 'html':
                        console.log('Exporting as HTML...');
                        // Use the cloned preview's innerHTML for consistency
                        const fullHTML = createFullHtml(clonedPreview.innerHTML);
                        triggerDownload(
                            URL.createObjectURL(new Blob([fullHTML], { type: 'text/html;charset=UTF-8' })),
                            'export.html'
                        );
                        showToast('HTML导出成功！');
                        break;

                    case 'docx':
                        console.log('Exporting as DOCX using html-docx-js...');
                        // Create the full HTML structure needed by the library
                        const docxHtmlString = createFullHtml(clonedPreview.innerHTML);

                        // --- >>> USE html-docx-js <<< ---
                        if (typeof htmlDocx === 'undefined') {
                            throw new Error("html-docx-js library not loaded correctly.");
                        }
                        // Convert the HTML string to a DOCX blob
                        const fileBlob = htmlDocx.asBlob(docxHtmlString);
                        // --- >>> END OF CHANGE <<< ---

                        triggerDownload(
                            URL.createObjectURL(fileBlob), // Create URL from blob
                            'export.docx'
                        );
                        showToast('DOCX导出成功！(样式基于Word HTML解析)');
                        break;
                }
            } catch (error) {
                showToast(`导出失败: ${error.message}`);
                console.error("Export Error:", error);
            } finally {
                // Clean up the temporary container
                if (document.body.contains(captureContainer)) {
                    document.body.removeChild(captureContainer);
                }
                exportButton.disabled = false; // Re-enable button
                exportButton.textContent = originalButtonText; // Restore original text
            }
        }


        // Helper to create full HTML structure for export
        function createFullHtml(bodyContent) {
            // Include necessary CSS links and highlight script for self-contained HTML/DOCX
            return `
                <!DOCTYPE html>
                <html lang="zh-CN" xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
                <head>
                    <meta charset="UTF-8">
                    <title>Exported Markdown</title>
                    <!-- Include base CSS for structure and styles Word might understand -->
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css">
                    <!-- Highlight.js CSS is less likely to be fully translated by Word, but include for completeness -->
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.css">
                    <style>
                        /* Styles Word might interpret */
                        body { font-family: Calibri, sans-serif; font-size: 11pt; padding: 1in; margin: 0; } /* Basic Word defaults */
                        .markdown-body { /* Apply some basic container-like properties if needed, Word handles page margins */
                             /* max-width: 6.5in; /* Example: Limit width within page */
                        }
                        /* Specific overrides for Word compatibility if needed */
                        pre { background-color: #f6f8fa; border: 1px solid #e1e4e8; padding: 1em; overflow: auto; font-family: Consolas, monospace; }
                        code { font-family: Consolas, monospace; font-size: 90%; }
                        table { border-collapse: collapse; width: 100%; }
                        th, td { border: 1px solid #dfe2e5; padding: 6px 13px; }
                        blockquote { border-left: .25em solid #dfe2e5; color: #6a737d; padding: 0 1em; margin-left: 0; }
                        /* Minimal styling from root variables Word might ignore */
                        :root { --preview-bg: #ffffff; --border-color: #e1e4e8; }
                    </style>
                     <!--[if gte mso 9]>
                     <xml>
                         <w:WordDocument>
                         <w:View>Print</w:View>
                         <w:Zoom>100</w:Zoom>
                         <w:DoNotOptimizeForBrowser/>
                         </w:WordDocument>
                     </xml>
                     <![endif]-->
                </head>
                <body>
                    <div class="markdown-body">
                        ${bodyContent}
                    </div>
                 </body>
                </html>
            `;
             // Removed highlight.js script tag as it's not needed for DOCX generation
             // Added Word-specific XML headers for better compatibility
        }


        // Universal download trigger
        function triggerDownload(dataURL, filename) {
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            if (dataURL.startsWith('blob:')) {
                setTimeout(() => URL.revokeObjectURL(dataURL), 100);
            }
        }

        // --- IndexedDB Logic ---
        function initDB() { // Logic remains the same
            return new Promise((resolve, reject) => {
                if (db) return resolve(db);
                const request = indexedDB.open(DB_NAME, 2);
                request.onerror = (event) => reject("Database error: " + event.target.error);
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("Database opened successfully (v2)");
                     getLastHistoryEntryContent().then(content => {
                         lastSavedHistoryContent = content;
                     }).catch(err => console.error("Error getting initial last history entry:", err));
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    console.log("Database upgrade needed");
                    const tempDb = event.target.result;
                    if (!tempDb.objectStoreNames.contains(SAVED_STORE_NAME)) {
                        const savedStore = tempDb.createObjectStore(SAVED_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        savedStore.createIndex('name', 'name', { unique: false });
                        savedStore.createIndex('timestamp', 'timestamp', { unique: false });
                        console.log("Object store 'savedMarkdown' created");
                    }
                    if (!tempDb.objectStoreNames.contains(HISTORY_STORE_NAME)) {
                        const historyStore = tempDb.createObjectStore(HISTORY_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        historyStore.createIndex('timestamp', 'timestamp', { unique: false });
                        console.log("Object store 'editHistory' created");
                    }
                };
            });
        }

        // --- Save/Load/Update/Delete for NAMED Documents (savedMarkdown store) ---
        async function saveMarkdown(name, content) { // Logic remains the same
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const timestamp = new Date();
                const request = store.add({ name, content, timestamp });
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject("Error saving: " + event.target.error);
                    transaction.onerror = (event) => reject("Save transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`保存失败: ${error}`); throw error; }
        }
        async function updateMarkdown(id, name, content) { // Logic remains the same
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const timestamp = new Date();
                const request = store.put({ id, name, content, timestamp });
                 return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(id);
                    request.onerror = (event) => reject("Error updating: " + event.target.error);
                    transaction.onerror = (event) => reject("Update transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`更新失败: ${error}`); throw error; }
        }
        async function loadAllMarkdown() { // Logic remains the same
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readonly');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const index = store.index('timestamp');
                const request = index.getAll();
                 return new Promise((resolve, reject) => {
                     request.onsuccess = () => {
                         const sortedResults = request.result.sort((a, b) => b.timestamp - a.timestamp);
                         resolve(sortedResults);
                     };
                     request.onerror = (event) => reject("Error loading all: " + event.target.error);
                     transaction.onerror = (event) => reject("Load all transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`加载列表失败: ${error}`); return []; }
        }
        async function loadMarkdownById(id) { // Logic remains the same
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readonly');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const request = store.get(id);
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject("Error loading by ID: " + event.target.error);
                     transaction.onerror = (event) => reject("Load ID transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`加载文档失败: ${error}`); return null; }
        }
        async function deleteMarkdownById(id) { // Logic remains the same
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const request = store.delete(id);
                 return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => reject("Error deleting: " + event.target.error);
                     transaction.onerror = (event) => reject("Delete transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`删除失败: ${error}`); return false; }
        }

        // --- EDIT HISTORY Logic (editHistory store) ---
        function scheduleHistorySave() { // Logic remains the same
            clearTimeout(historySaveTimeout);
            historySaveTimeout = setTimeout(() => {
                saveCurrentStateToHistory();
            }, 2000);
        }
        function triggerHistorySave() { // Logic remains the same
             clearTimeout(historySaveTimeout);
             setTimeout(() => { saveCurrentStateToHistory(); }, 0);
        }
        async function saveCurrentStateToHistory() { // Logic remains the same (with sample check)
            const content = editor.value;
            if (content === sampleContent) { return; }
            if (!content.trim() || content === lastSavedHistoryContent) { return; }

            console.log("Saving to history...");
            try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const timestamp = new Date();
                const request = store.add({ content, timestamp });
                request.onsuccess = () => {
                    console.log("History entry saved successfully:", request.result);
                    lastSavedHistoryContent = content;
                    pruneHistory();
                };
                request.onerror = (event) => console.error("Error saving history entry:", event.target.error);
                transaction.onerror = (event) => console.error("History save transaction error:", event.target.error);
            } catch (error) { console.error("Failed to initiate history save:", error); }
        }
        async function pruneHistory() { // Logic remains the same
            try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const countRequest = store.count();
                countRequest.onsuccess = () => {
                    const count = countRequest.result;
                    if (count > HISTORY_LIMIT) {
                        const itemsToDelete = count - HISTORY_LIMIT;
                        let deletedCount = 0;
                        const index = store.index('timestamp');
                        const cursorRequest = index.openCursor(null, 'next');
                        cursorRequest.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor && deletedCount < itemsToDelete) {
                                cursor.delete(); deletedCount++; cursor.continue();
                            } else { console.log(`Pruning complete. Deleted ${deletedCount} entries.`); }
                        };
                        cursorRequest.onerror = (event) => console.error("Error opening cursor for pruning:", event.target.error);
                    }
                };
                countRequest.onerror = (event) => console.error("Error counting history items:", event.target.error);
                 transaction.onerror = (event) => console.error("History prune transaction error:", event.target.error);
            } catch (error) { console.error("Failed to initiate history pruning:", error); }
        }
        async function loadAllHistory() { // Logic remains the same
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readonly');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const index = store.index('timestamp');
                const request = index.getAll();
                return new Promise((resolve, reject) => {
                     request.onsuccess = () => {
                         const sortedResults = request.result.sort((a, b) => b.timestamp - a.timestamp);
                         resolve(sortedResults);
                     };
                     request.onerror = (event) => reject("Error loading history: " + event.target.error);
                     transaction.onerror = (event) => reject("Load history transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`加载历史失败: ${error}`); return []; }
        }
        async function loadHistoryById(id) { // Logic remains the same
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readonly');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const request = store.get(id);
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject("Error loading history ID: " + event.target.error);
                     transaction.onerror = (event) => reject("Load history ID transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`加载历史条目失败: ${error}`); return null; }
        }
        async function deleteHistoryById(id) { // Logic remains the same
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const request = store.delete(id);
                 return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => reject("Error deleting history: " + event.target.error);
                     transaction.onerror = (event) => reject("Delete history transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`删除历史失败: ${error}`); return false; }
        }
         async function getLastHistoryEntryContent() { // Logic remains the same
             return new Promise(async (resolve, reject) => {
                 try {
                    const dbInstance = await initDB();
                    const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(HISTORY_STORE_NAME);
                    const index = store.index('timestamp');
                    const cursorRequest = index.openCursor(null, 'prev');
                    cursorRequest.onsuccess = (event) => {
                        const cursor = event.target.result;
                        resolve(cursor ? cursor.value.content : null);
                    };
                    cursorRequest.onerror = (event) => reject("Error getting last history entry: " + event.target.error);
                    transaction.onerror = (event) => reject("Last history transaction error: " + event.target.error);
                 } catch (error) { reject("Failed to initiate get last history: " + error); }
             });
         }

        // --- UI Interaction for Modals ---
        function showLoadModal() { populateModal(false); } // Logic remains the same
        function showSaveModal() { populateModal(true); } // Logic remains the same
        function hideLoadModal() { loadModal.style.display = 'none'; } // Logic remains the same
        async function populateModal(isSavingMode = false) { // Logic remains the same
            modalTitle.textContent = isSavingMode ? "保存或更新 Markdown" : "加载已保存的 Markdown";
            saveNewButton.style.display = isSavingMode ? 'inline-flex' : 'none';
            searchInput.value = '';
            try {
                const items = await loadAllMarkdown();
                savedItemList.innerHTML = '';
                const noItemsLi = '<li class="no-items">没有找到已保存的文档。</li>';
                if (items && items.length > 0) {
                    items.forEach(item => { /* ... item creation ... */
                        const li = document.createElement('li');
                        li.className = 'saved-item';
                        li.dataset.id = item.id; li.dataset.name = item.name;
                        li.innerHTML = `
                            <div class="item-info">
                                <span class="item-name" title="${escapeHtml(item.name)}">${escapeHtml(item.name)}</span>
                                <span class="item-timestamp">保存于: ${formatTimestamp(item.timestamp)}</span>
                            </div>
                            <div class="item-actions">
                                ${isSavingMode ? `<button class="small" onclick="handleUpdateItem(event, ${item.id})" title="使用当前编辑器内容覆盖此项">更新</button>` : ''}
                                <button class="small" onclick="handleLoadItem(${item.id})" title="加载此项到编辑器">加载</button>
                                <button class="small danger" onclick="handleDeleteItem(event, ${item.id}, 'saved')" title="删除此项">删除</button>
                            </div>`;
                        savedItemList.appendChild(li);
                    });
                    const existingNoItems = savedItemList.querySelector('.no-items');
                    if(existingNoItems) existingNoItems.remove();
                } else { savedItemList.innerHTML = noItemsLi; }
                 filterSavedItems();
                 loadModal.style.display = 'block';
            } catch (error) {
                showToast(`加载列表失败: ${error}`);
                savedItemList.innerHTML = '<li class="no-items" style="color:red;">加载列表时出错。</li>';
                loadModal.style.display = 'block';
            }
        }
        function filterSavedItems() { // Logic remains the same
            const filter = searchInput.value.toLowerCase();
            const items = savedItemList.querySelectorAll('li.saved-item');
            let visibleCount = 0;
            const noItemsMessage = savedItemList.querySelector('.no-items') || document.createElement('li');
            noItemsMessage.className = 'no-items';
            noItemsMessage.textContent = filter ? '没有匹配的文档。' : '没有找到已保存的文档。';
            items.forEach(item => {
                const name = item.dataset.name ? item.dataset.name.toLowerCase() : '';
                if (name.includes(filter)) { item.style.display = 'flex'; visibleCount++; }
                else { item.style.display = 'none'; }
            });
             if (visibleCount === 0 && items.length > 0) { if (!savedItemList.contains(noItemsMessage)) savedItemList.appendChild(noItemsMessage); noItemsMessage.style.display = 'block'; }
             else if (visibleCount > 0) { if (savedItemList.contains(noItemsMessage)) noItemsMessage.style.display = 'none'; }
             else if (items.length === 0) { if (!savedItemList.contains(noItemsMessage)) { savedItemList.innerHTML = ''; savedItemList.appendChild(noItemsMessage); } noItemsMessage.style.display = 'block'; }
        }
        function showHistoryModal() { populateHistoryModal(); } // Logic remains the same
        function hideHistoryModal() { historyModal.style.display = 'none'; } // Logic remains the same
        async function populateHistoryModal() { // Logic remains the same
             try {
                const items = await loadAllHistory();
                historyItemList.innerHTML = '';
                const noItemsLi = '<li class="no-items">没有编辑历史记录。</li>';
                if (items && items.length > 0) {
                    items.forEach(item => { /* ... item creation ... */
                        const li = document.createElement('li');
                        li.className = 'history-item';
                        li.dataset.id = item.id;
                        const previewText = item.content.substring(0, 60).replace(/\n/g, ' ') + (item.content.length > 60 ? '...' : '');
                        li.innerHTML = `
                            <div class="item-info">
                                <span class="item-timestamp">记录于: ${formatTimestamp(item.timestamp)}</span>
                                <span class="item-content-preview" title="${escapeHtml(item.content.substring(0, 200))}">${escapeHtml(previewText)}</span>
                            </div>
                            <div class="item-actions">
                                <button class="small primary" onclick="handleRestoreHistory(${item.id})" title="恢复此版本到编辑器">恢复</button>
                                <button class="small danger" onclick="handleDeleteItem(event, ${item.id}, 'history')" title="删除此历史记录">删除</button>
                            </div>`;
                        historyItemList.appendChild(li);
                    });
                     const existingNoItems = historyItemList.querySelector('.no-items');
                    if(existingNoItems) existingNoItems.remove();
                } else { historyItemList.innerHTML = noItemsLi; }
                 historyModal.style.display = 'block';
            } catch (error) {
                showToast(`加载历史列表失败: ${error}`);
                historyItemList.innerHTML = '<li class="no-items" style="color:red;">加载历史列表时出错。</li>';
                historyModal.style.display = 'block';
            }
        }

        // --- Action Handlers (Load/Save/Update/Delete/History) ---
        async function handleSaveNew() { // Logic remains the same
            const content = editor.value;
            if (!content.trim()) { showToast("编辑器内容为空，无法保存。"); return; }
            const defaultName = `Markdown ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`;
            const name = prompt("请输入新文档的名称:", defaultName);
            if (name === null || name.trim() === "") { showToast("已取消保存或名称无效。"); return; }
            try { await saveMarkdown(name.trim(), content); showToast(`"${name.trim()}" 已成功保存！`); hideLoadModal(); }
            catch (error) { console.error("Save new failed:", error); }
        }
        async function handleUpdateItem(event, id) { // Logic remains the same
            event.stopPropagation();
            const content = editor.value;
            if (!content.trim()) { showToast("编辑器内容为空，无法更新。"); return; }
            try {
                const itemToUpdate = await loadMarkdownById(id);
                if (!itemToUpdate) { showToast("找不到要更新的项目。"); populateModal(true); return; }
                if (confirm(`确定要用当前编辑器内容覆盖 "${itemToUpdate.name}" 吗？`)) {
                    const newName = prompt("请输入更新后的名称（留空则保留原名）:", itemToUpdate.name);
                     if (newName === null) { showToast("更新已取消。"); return; }
                    const finalName = (newName.trim() === "") ? itemToUpdate.name : newName.trim();
                    await updateMarkdown(id, finalName, content); showToast(`"${finalName}" 已成功更新！`); hideLoadModal();
                } else { showToast("更新已取消。"); }
            } catch (error) { console.error("Update failed:", error); }
        }
        async function handleLoadItem(id) { // Logic remains the same
            console.log(`Attempting to load saved item ID: ${id}`);
             try {
                 const item = await loadMarkdownById(id);
                 if (item) {
                     editor.value = item.content; updatePreview(); hideLoadModal(); editor.scrollTop = 0;
					 showToast(`已加载: ${item.name}`); triggerHistorySave();
                 } else { showToast("无法找到该项目。"); }
             } catch (error) { console.error("Load item failed:", error); }
        }
        async function handleRestoreHistory(id) { // Logic remains the same
            console.log(`Attempting to restore history ID: ${id}`);
             try {
                 const item = await loadHistoryById(id);
                 if (item) {
                     editor.value = item.content; updatePreview(); hideHistoryModal(); editor.scrollTop = 0;
					 showToast(`已从 ${formatTimestamp(item.timestamp)} 恢复`);
                     lastSavedHistoryContent = item.content; // Update tracker
                 } else { showToast("无法找到该历史记录。"); }
             } catch (error) { console.error("Restore history failed:", error); }
        }
        async function handleDeleteItem(event, id, type) { // Logic remains the same
             event.stopPropagation();
             console.log(`Attempting to delete ${type} item ID: ${id}`);
             const listElement = (type === 'saved') ? savedItemList : historyItemList;
             const itemElement = listElement.querySelector(`li[data-id='${id}']`);
             const itemName = (type === 'saved' && itemElement) ? itemElement.dataset.name : `此${type === 'saved' ? '文档' : '历史记录'}`;
             const deleteFunction = (type === 'saved') ? deleteMarkdownById : deleteHistoryById;

             if (confirm(`确定要删除 "${itemName}" 吗？此操作无法撤销。`)) {
                 try {
                     const success = await deleteFunction(id);
                     if (success) {
                        if (itemElement) {
                            itemElement.style.transition = 'opacity 0.3s ease-out, height 0.3s ease-out, margin 0.3s ease-out, padding 0.3s ease-out, border 0.3s ease-out';
                            itemElement.style.opacity = '0'; itemElement.style.height = '0'; itemElement.style.margin = '0'; itemElement.style.padding = '0'; itemElement.style.border = 'none';
                            setTimeout(() => {
                                if (itemElement.parentNode) itemElement.remove();
                                if (type === 'saved') { filterSavedItems(); }
                                else { if (historyItemList.querySelectorAll('.history-item').length === 0) { historyItemList.innerHTML = '<li class="no-items">没有编辑历史记录。</li>'; } }
                            }, 300);
                        }
                        showToast(`"${itemName}" 已删除。`);
                     } else { showToast(`删除 "${itemName}" 失败。`); }
                 } catch (error) { console.error(`Delete ${type} failed:`, error); }
             }
        }

        // Close modals on outside click
        window.onclick = function(event) { // Logic remains the same
            if (event.target == loadModal) hideLoadModal();
            if (event.target == historyModal) hideHistoryModal();
        }

        // --- Utility Functions ---
        function escapeHtml(unsafe) { // Logic remains the same
            if (typeof unsafe !== 'string') return '';
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
         }
         function formatTimestamp(date) { // Logic remains the same
             if (!(date instanceof Date)) date = new Date(date);
             if (isNaN(date)) return "Invalid Date";
             try { return date.toLocaleString('zh-CN', { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' }); }
             catch (e) { console.error("Error formatting date:", e); return "Error Date"; }
        }

        // --- Scroll Sync ---
		function syncScroll(source, target) { // Logic remains the same
			if (isSyncing) return;
			isSyncing = true;
			const ratio = source.scrollTop / (source.scrollHeight - source.clientHeight || 1);
			target.scrollTop = ratio * (target.scrollHeight - target.clientHeight);
			requestAnimationFrame(() => { isSyncing = false; });
		}
		editor.addEventListener('scroll', () => syncScroll(editor, preview));
		preview.addEventListener('scroll', () => syncScroll(preview, editor));

        // --- Initialization ---
        editor.addEventListener('input', () => { // Logic remains the same
            updatePreview();
            scheduleHistorySave();
        });
        editor.addEventListener('paste', () => { // Logic remains the same
            setTimeout(() => { updatePreview(); triggerHistorySave(); }, 0);
        });
        editor.addEventListener('blur', () => { // Logic remains the same
             clearTimeout(historySaveTimeout);
             saveCurrentStateToHistory();
        });

        // Load sample and initialize DB on page load
        loadSample(); // Load sample by default
        initDB().then(() => { // Logic remains the same
            console.log("DB Initialized.");
            pruneHistory();
        }).catch(err => console.error("Initial DB connection failed:", err));

    </script>
</body>
</html>