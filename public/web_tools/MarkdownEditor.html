<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-UTF-8">
    <title>Markdown转换工具</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- PDF/Image Export Libs -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- DOCX Export Lib -->
    <script src="https://unpkg.com/html-docx-js/dist/html-docx.js"></script>
    <!-- Highlight JS -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.css" integrity="sha512-jYtlOKxyOGJQxuHAR9h4PK04vh9HzaxI0dHVXx/kqICgw82nv3UpzWkaef+Fg8g4XJEvf/W+sPOnaeYQp5SRaQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Diff Lib (jsdiff) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/7.0.0/diff.min.js"></script>
    <style>
         :root {
            --bg-color: #f8f9fa;
            --preview-bg: #ffffff;
            --border-color: #e1e4e8;
            --text-color: #24292e;
            --secondary-text-color: #6a737d;
            --primary-color: #0366d6;
            --primary-hover-color: #0056b3;
            --danger-color: #d73a49;
            --danger-hover-color: #cb2431;
            --modal-overlay-bg: rgba(0,0,0,0.6);
            --modal-content-bg: #ffffff;
            --diff-enabled-color: #28a745; /* Bootstrap Success Green */
            --diff-disabled-color: #6c757d; /* Bootstrap Secondary Grey */
            --tracking-strong-color: #28a745;
            --tracking-weak-color: #dc3545;
            --warning-color: #ffc107; /* Bootstrap Warning Yellow/Orange */
        }

        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .container {
            padding: 2rem;
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 2rem;
            margin: 0 auto;
            height: calc(100vh - 1rem);
            box-sizing: border-box;
        }

        .editor-box, .preview-box {
            background: var(--preview-bg);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow: hidden;
            min-width: 0;
        }

        .markdown-body {
            background: var(--preview-bg) !important;
            padding: 1.5rem !important;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            overflow: auto;
        }

        .title-toolbar {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .preview-title-extra { 
            /*margin-left: auto;*/ 
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        #trackingStrengthIndicator, #changeSummaryIndicator {
            font-size: 0.8em;
            font-weight: 500;
            padding: 0.2em 0.5em;
            border-radius: 4px;
            white-space: nowrap;
            margin-right: 5px;
        }
        #trackingStrengthIndicator.strong { color: var(--tracking-strong-color); border: 1px solid var(--tracking-strong-color);}
        #trackingStrengthIndicator.weak { color: var(--tracking-weak-color); border: 1px solid var(--tracking-weak-color);}
        #changeSummaryIndicator { color: var(--secondary-text-color); font-weight: normal;}


        #diffStatusIndicator {
            font-size: 0.8em; 
            font-weight: 500;
            padding: 0.2em 0.6em; 
            border-radius: 4px;
            color: white;
            line-height: 1.5; 
            white-space: nowrap;
        }
        #diffStatusIndicator.enabled {
            background-color: var(--diff-enabled-color);
        }
        #diffStatusIndicator.disabled {
            background-color: var(--diff-disabled-color);
        }

        #longTextWarning {
            color: var(--warning-color);
            font-size: 0.8em;
            margin-left: 5px;
            font-weight: 500;
        }


        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px; 
            height: 20px; 
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px; 
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px; 
            width: 14px;  
            left: 3px;    
            bottom: 3px;  
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px); 
        }


        select, button, input[type="search"], input[type="number"], input[type="range"] {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: white;
            font-size: 0.9em;
            box-sizing: border-box;
        }
        input[type="range"] {
            padding: 0; 
        }
        button {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        button:hover {
             border-color: #c6cbd1;
             background-color: #f6f8fa;
        }
        button:active {
             background-color: #f3f4f6;
             border-color: #c6cbd1;
             box-shadow: inset 0 1px 0 rgba(225,228,232,0.2);
        }


        button.primary {
            background: var(--primary-color);
            color: white;
            border: 1px solid var(--primary-color);
        }

        button.primary:hover {
            background: var(--primary-hover-color);
            border-color: var(--primary-hover-color);
        }

        button.danger {
            background-color: var(--danger-color);
            color: white;
            border-color: var(--danger-color);
         }
         button.danger:hover {
            background-color: var(--danger-hover-color);
            border-color: var(--danger-hover-color);
         }
         button.small {
            padding: 0.3rem 0.8rem;
            font-size: 0.8em;
         }

         .notice {
            color: var(--secondary-text-color);
            font-size: 0.9em;
            margin-top: 0;
        }
        .card-title {
            padding: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            flex-shrink: 0;
            box-sizing: border-box;
            flex-wrap: wrap;
            gap: 10px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
        }
        .card-body {
            flex-grow: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .text-title {
            font-size: 1.25em;
            font-weight: 600;
            margin-right: 1rem; 
            white-space: nowrap;
            display: flex; 
            align-items: center; 
			gap: 0.5rem;
        }

        .active-doc-name {
            font-weight: normal;
            font-size: 0.8em;
            color: var(--secondary-text-color);
            margin-left: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px; 
            vertical-align: middle; 
            display: inline-block; 
        }
        .active-doc-status {
            font-weight: normal;
            font-size: 0.8em;
            color: var(--secondary-text-color);
            margin-left: 4px;
            white-space: nowrap;
            vertical-align: middle;
            display: inline-block;
        }

        .title-button-group {
             display: flex;
             gap: 0.5rem;
             align-items: center;
			 width: 100%;
			 justify-content: flex-end;
        }
		.title-button-item {
			height: 35px;
			min-width: 75px;
			display: inline-flex;
			align-items: center;
			justify-content: center;
            gap: 0.4em;
            padding: 0.5rem 0.8rem;
            white-space: nowrap;
			text-overflow: ellipsis;
		}
        .icon-button svg {
            vertical-align: middle;
            flex-shrink: 0;
        }
        .editor {
            width: 100%;
            font-family: 'Fira Code', 'Consolas', monospace;
            border-radius: 6px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            border: 1px solid var(--border-color);
            background: #fafafa;
        }

        #editor {
            width: 100%;
            flex-grow: 1;
            padding: 15px;
            font-size: 14px;
            line-height: 1.6;
            border: none;
            background: transparent;
            resize: none;
            tab-size: 4;
            overflow-y: auto;
            box-sizing: border-box;
        }

        #editor:focus {
            outline: none;
        }

        .toolbar {
            padding: 8px 15px;
            background: #f6f8fa;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.85em;
            color: var(--secondary-text-color);
            flex-shrink: 0;
            box-sizing: border-box;
            width: 100%;
            user-select: none;
        }

		.modal {
			display: none; /* 确保默认是隐藏的 */
			position: fixed;
			z-index: 1000;
			left: 0;
			top: 0;
			width: 100%;
			height: 100vh; /* 使用视窗高度单位 vh */
			overflow: hidden; /* 禁止 modal 本身滚动 */
			background-color: var(--modal-overlay-bg);
			backdrop-filter: blur(3px);
		}

		/* 当 JS 将 .modal 设置为 display: flex; 时，以下样式用于居中 modal-content */
		.modal.show-flex { /* 创建一个新类给 JS 来切换 */
			display: flex;
			align-items: center;
			justify-content: center;
		}


		.modal-content {
			background-color: var(--modal-content-bg);
			/* margin: 8% auto; */ /* 移除，由 .modal.show-flex 的 flex 布局处理居中 */
			margin: 20px; /* 可以给一个固定的外边距，防止贴边，并为 max-height 计算留出空间 */
			padding: 25px;
			border: 1px solid var(--border-color);
			width: 85%;
			max-width: 650px;
			border-radius: 8px;
			box-shadow: 0 5px 15px rgba(0,0,0,0.2);
			position: relative; /* 保持 */
			animation: fadeIn 0.3s ease-out;
			display: flex; /* 内部仍然是flex布局 */
			flex-direction: column;
			gap: 1rem;
			max-height: calc(100vh - 40px); /* 限制最大高度，减去上下margin (20px + 20px) */
			overflow-y: auto; /* 当内容超出 modal-content 的 max-height 时，内容区才滚动 */
		}
		
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.8rem;
        }

        .modal-close-btn {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            line-height: 1;
            background: none;
            border: none;
            padding: 0 5px;
            cursor: pointer;
        }

        .modal-close-btn:hover,
        .modal-close-btn:focus {
            color: black;
            text-decoration: none;
        }

        .modal h2 {
            margin: 0;
            font-weight: 600;
            font-size: 1.3em;
        }
        .modal-toolbar {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        #searchInput, #historySearchInput {
            flex-grow: 1;
            min-width: 200px;
        }
        #saveNewButton, #saveAsVersionButton {
             display: none;
        }


        .saved-item-list, .history-item-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 50vh;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }

        .saved-item, .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
            transition: background-color 0.15s ease-in-out, border-left 0.15s ease-in-out; 
            gap: 10px;
        }
        .saved-item:last-child, .history-item:last-child {
            border-bottom: none;
        }
        .saved-item:hover, .history-item:hover {
            background-color: #f6f8fa;
        }
        .saved-item.highlighted-active-doc {
            background-color: #e6f7ff; 
            border-left: 4px solid var(--primary-color);
            font-weight: 500;
        }
        .saved-item.highlighted-active-doc .item-name {
            color: var(--primary-hover-color);
        }


        .item-info {
            display: flex;
            flex-direction: column;
            gap: 3px;
            flex-grow: 1;
            min-width: 0;
        }

        .item-name {
            font-weight: 500;
            color: var(--text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .item-content-preview {
            font-size: 0.9em;
            color: var(--secondary-text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 350px;
            display: inline-block;
        }

        .item-timestamp {
            font-size: 0.8em;
            color: var(--secondary-text-color);
        }
        .item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .no-items {
             text-align: center;
             color: var(--secondary-text-color);
             padding: 2rem 0;
             font-style: italic;
             border-bottom: none !important;
             display: block !important;
        }
        .no-items:hover {
             background-color: transparent !important;
        }
        .toast-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            border-radius: 6px;
            z-index: 1050;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            text-align: center;
            pointer-events: none;
        }
        .toast-message.show {
            opacity: 1;
        }
        /* Styles for Diff Config Modal */
        .config-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .config-item label {
            font-weight: 500;
            font-size: 0.95em;
        }
        .config-item .input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .config-item input[type="number"] {
            width: 100px; /* Increased width for threshold input */
        }
        .config-item input[type="range"] {
            flex-grow: 1;
        }
        .config-item select {
            flex-grow: 1;
        }
        .config-note {
            font-size: 0.8em;
            color: var(--secondary-text-color);
            margin-top: 0.2rem;
        }
		#wordCountIndicator {
			font-size: 0.8em;
			color: var(--secondary-text-color);
			margin-left: 0.75rem; /* 与其他指示器间隔保持一致 */
			white-space: nowrap;
		}

		/* 确保 .preview-title-extra (包含强度和摘要的那个) 与字数统计有间隔 */
		.text-title > .preview-title-extra {
			 margin-left: 0.75rem; /* 如果字数统计存在，这个div向右移一点 */
		}

		/* 微调 .text-title 以容纳更多元素 */
		.text-title {
			font-size: 1.25em;
			font-weight: 600;
			/* margin-right: 1rem; */ /* 可以移除或减小，因为右侧现在有更多元素 */
			white-space: nowrap;
			display: flex; 
			align-items: center; 
			gap: 0.5rem; /* 保持子元素间的间隙 */
			flex-grow: 1; /* 让 text-title 占据可用空间，以推动右侧的开关组 */
			min-width: 0; /* 防止内容过长时撑开布局 */
		}
		.preview-box .card-title .preview-title-extra:nth-of-type(2){ /* 指向包含开关的那个 preview-title-extra */
			/* margin-left: auto; /* 确保开关组靠右 */
		}
    </style>
</head>
<body>
    <div class="container">
        <!-- 编辑区 -->
        <div class="editor-box">
            <div class="card-title">
                <div class="text-title">
                    Markdown 编辑器
                    <span id="activeDocNameIndicator" class="active-doc-name"></span><span id="activeDocStatusIndicator" class="active-doc-status"></span>
                </div>
                <div class="title-button-group">
                    <button onclick="importMarkdownFile()" title="导入 Markdown 文件" class="title-button-item icon-button">
						<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-upload"><path d="M2.75 14A1.75 1.75 0 0 1 1 12.25v-2.5a.75.75 0 0 1 1.5 0v2.5c0 .138.112.25.25.25h10.5a.25.25 0 0 0 .25-.25v-2.5a.75.75 0 0 1 1.5 0v2.5A1.75 1.75 0 0 1 13.25 14Z M8 1.75a.75.75 0 0 1 .75.75v6.51L11.03 6.78a.75.75 0 0 1 1.06 1.06l-3.5 3.5a.75.75 0 0 1-1.06 0l-3.5-3.5a.75.75 0 1 1 1.06-1.06l2.22 2.22V2.5a.75.75 0 0 1 .75-.75Z"></path></svg>
						导入
					</button>
                    <button onclick="showLoadModal()" title="加载已保存的 Markdown" class="title-button-item icon-button">
						<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-download"><path d="M2.75 14A1.75 1.75 0 0 1 1 12.25v-2.5a.75.75 0 0 1 1.5 0v2.5c0 .138.112.25.25.25h10.5a.25.25 0 0 0 .25-.25v-2.5a.75.75 0 0 1 1.5 0v2.5A1.75 1.75 0 0 1 13.25 14Z M8 11.75a.75.75 0 0 1-.75-.75V1.5a.75.75 0 0 1 1.5 0v9.5a.75.75 0 0 1-.75.75Zm-4.28-4.28a.75.75 0 0 1 0-1.06l4.25-4.25a.75.75 0 0 1 1.06 0l4.25 4.25a.75.75 0 0 1-1.06 1.06L8.75 4.31V9.5a.75.75 0 0 1-1.5 0V4.31L3.78 7.47a.75.75 0 0 1-1.06 0Z"></path></svg>
						加载
					</button>
                    <button class="primary title-button-item icon-button" onclick="showSaveModal()" title="保存或更新 Markdown">
						<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-file-directory-fill"><path d="M1.75 1A1.75 1.75 0 0 0 0 2.75v10.5C0 14.216.784 15 1.75 15h12.5A1.75 1.75 0 0 0 16 13.25v-8.5A1.75 1.75 0 0 0 14.25 3H7.5a.25.25 0 0 1-.2-.09L5.95 1.36A.75.75 0 0 0 5.41 1H1.75Z"></path></svg>
						保存
					</button>
                    <button onclick="showHistoryModal()" title="查看编辑历史" class="title-button-item icon-button">
						<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-history"><path d="M1.643 3.143L.427 1.927A.25.25 0 0 0 0 2.104V5.75c0 .138.112.25.25.25h3.646a.25.25 0 0 0 .177-.427L2.715 4.215a6.5 6.5 0 1 1-1.18 4.458.75.75 0 1 0-1.493.154 8.001 8.001 0 1 0 1.6-5.684zM7.75 4a.75.75 0 0 1 .75.75v4.336l3.47 2.023a.75.75 0 0 1-.74 1.298l-3.75-2.165A.75.75 0 0 1 7 9.75V4.75a.75.75 0 0 1 .75-.75z"></path></svg>
						历史
					</button>
                    <button onclick="showDiffConfigModal()" title="配置智能识别关联" class="title-button-item icon-button">
                        <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-gear"><path fill-rule="evenodd" d="M8 11.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Zm0 1.5a5 5 0 1 0 0-10 5 5 0 0 0 0 10ZM5.44 8A2.56 2.56 0 0 1 8 5.44v.035a.75.75 0 0 1 0 1.5v-.035A.97.97 0 0 0 8 6.91a.97.97 0 0 0-.97.97.97.97 0 0 0 .97.97.97.97 0 0 0 .97-.97V8a2.56 2.56 0 0 1-2.56 2.56H5.47a.75.75 0 0 1 0-1.5h.005A2.524 2.524 0 0 1 5.44 8Zm4.12-2.56A2.56 2.56 0 0 1 10.53 8h.005a.75.75 0 0 1 0 1.5H10.5A2.56 2.56 0 0 1 8 10.56v-.035a.75.75 0 0 1 0-1.5v.035A.97.97 0 0 0 8 9.09a.97.97 0 0 0 .97-.97A.97.97 0 0 0 8 7.15.97.97 0 0 0 7.03 8.12V8A2.56 2.56 0 0 1 9.56 5.44Zm2.06.7a.75.75 0 0 1 1.06-.02l.003.004 1.5 1.5.003.003a.75.75 0 0 1 .02 1.06l-.003.004-1.5 1.5-.004.003a.75.75 0 0 1-1.06.02l.004-.003-1.5-1.5-.004-.003a.75.75 0 0 1-.02-1.06l.003-.004 1.5-1.5Zm-8.24 4.12a.75.75 0 0 1 1.06.02l-.003-.004 1.5 1.5-.003-.003a.75.75 0 0 1 .02 1.06l.003.004-1.5 1.5.004.003a.75.75 0 0 1-1.06.02l-.004-.003-1.5-1.5.004-.003a.75.75 0 0 1-.02-1.06l-.003.004 1.5-1.5Z"></path></svg>
                        关联设置
                    </button>
					<button id="loadSampleOrRevertButton" class="title-button-item" onclick="handleLoadSampleOrRevert()" >加载示例</button>
                </div>
            </div>
            <div class="card-body">
                <div class="editor">
                    <div class="toolbar">Markdown Editor (Tab/Shift+Tab supported)</div>
                    <textarea id="editor" placeholder="Start typing markdown here..."></textarea>
                </div>
            </div>
        </div>

        <!-- 预览区 -->
        <div class="preview-box">
            <div  class="card-title">
                <div class="text-title">
                    <div>实时预览</div>
					<span id="wordCountIndicator" class="word-count-indicator"></span>
					<div class="preview-title-extra" >
					    <span id="trackingStrengthIndicator" style="display: none;" title="当前使用的方案存续未修改部分的百分比"></span>
					    <span id="changeSummaryIndicator" style="display: none;" title="当前编辑器中对比使用的方案初始状态的差异"></span>
					</div>
                </div>
                <div class="preview-title-extra">
					<span id="diffStatusIndicator">智能识别: 关闭</span>
                    <span id="longTextWarning" style="display: none;"></span>
					<label class="toggle-switch" title="开启/关闭智能识别关联功能">
					    <input type="checkbox" id="diffTrackingToggle">
					    <span class="slider"></span>
					</label>
				</div>
                <div class="title-toolbar">
                    <select id="format">
                        <option value="image" selected>图片</option>
                        <option value="html">HTML</option>
                        <option value="pdf">PDF</option>
                        <option value="docx">DOCX</option>
                        <option value="markdown">Markdown (.md)</option>
                    </select>
                    <button class="primary" onclick="exportFile(event)">导出文件</button>
                    <p class="notice">提示：生成图片/PDF可能需5-10秒</p>
                </div>
            </div>
            <div class="card-body">
                <div class="markdown-body" id="preview"></div>
            </div>
        </div>
    </div>

     <!-- Load/Save Markdown Modal -->
    <div id="loadModal" class="modal">
        <div class="modal-content">
             <div class="modal-header">
                 <h2 id="modalTitle">加载已保存的 Markdown</h2>
                 <button class="modal-close-btn" onclick="hideLoadModal()" title="关闭">&times;</button>
             </div>
             <div class="modal-toolbar">
                <input type="search" id="searchInput" placeholder="按名称搜索..." oninput="filterSavedItems()">
                <button id="saveAsVersionButton" class="primary" onclick="handleSaveAsVersion()" style="display: none;">另存为版本...</button>
                <button id="saveNewButton" class="primary" onclick="handleSaveNew()">另存为新...</button>
             </div>
            <ul id="savedItemList" class="saved-item-list">
                 <li class="no-items">没有找到已保存的文档。</li>
            </ul>
        </div>
    </div>

    <!-- Edit History Modal -->
    <div id="historyModal" class="modal">
        <div class="modal-content">
             <div class="modal-header">
                 <h2 id="historyModalTitle">编辑历史记录</h2>
                 <button class="modal-close-btn" onclick="hideHistoryModal()" title="关闭">&times;</button>
             </div>
            <ul id="historyItemList" class="history-item-list">
                 <li class="no-items">没有编辑历史记录。</li>
            </ul>
        </div>
    </div>

    <!-- Diff Config Modal -->
    <div id="diffConfigModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>智能识别设置</h2>
                <button class="modal-close-btn" onclick="hideDiffConfigModal()" title="关闭">&times;</button>
            </div>
            <div class="config-item">
                <label for="longTextThresholdInput">长文本阈值 (字符数)</label>
                <div class="input-group">
                    <input type="number" id="longTextThresholdInput" min="5000" step="1000">
                </div>
                <p class="config-note">当文本超过此字符数时，视为长文本，可能会触发性能优化策略。最小5000。</p>
            </div>
            <div class="config-item">
                <label for="autoDisableDiffForLongTextToggle">长文本时自动关闭智能识别</label>
                <div class="input-group" style="justify-content: space-between; align-items: center;">
                    <span id="autoDisableDiffInfo" style="font-size: 0.9em; color: var(--secondary-text-color);"></span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="autoDisableDiffForLongTextToggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <p class="config-note">开启后，在编辑超长文档时将自动临时关闭智能识别功能，以保持应用流畅。清除长文本后会自动恢复原设置。</p>
            </div>
            <hr style="border: none; border-top: 1px solid var(--border-color); margin: 1rem 0;">
            <div class="config-item">
                <label for="diffAlgorithmSelect">比较方式</label>
                <select id="diffAlgorithmSelect">
                    <option value="chars">字符级 (Char by Char)</option>
                    <option value="words">词语级 (Word by Word)</option>
                    <option value="lines">行级 (Line by Line)</option>
                </select>
                <p class="config-note">选择比较文本差异的精细程度。不同方式对关联判断结果有影响。</p>
            </div>
            <div class="config-item">
                <label for="diffDebounceTimeInput">内容更新检测延迟 (毫秒)</label>
                <div class="input-group">
                    <input type="number" id="diffDebounceTimeInput" min="1000" step="100">
                </div>
                <p class="config-note">停止输入后，等待这么长时间再判断当前内容是否与原文档关联。最短1秒 (1000毫秒)。</p>
            </div>
            <div class="config-item">
                <label for="diffMatchThresholdInput">原文相似度要求 (%)</label>
                <div class="input-group">
                    <input type="range" id="diffMatchThresholdRange" min="50" max="100" step="1">
                    <input type="number" id="diffMatchThresholdInput" min="50" max="100" step="1" style="width: 70px;"> %
                </div>
                <p class="config-note">当已保存文档中，至少有这个百分比的内容还存在于当前编辑区时，系统会认为您仍在修改该文档。范围50% - 100%。</p>
            </div>
            <button class="primary" onclick="handleSaveDiffSettings()">保存配置</button>
        </div>
    </div>


    <!-- 独立示例内容 -->
    <script id="sampleMarkdown" type="text/template">
# 现代化文档转换工具 (v2.4)

## 功能特性

- [x] ​**​实时HTML预览​**​
- [x] 多格式导出支持 (HTML, 图片, **PDF**, **DOCX**, **Markdown**)
- [x] 专业样式渲染 (GitHub Markdown CSS + Highlight.js)
- [x] 内容本地存储 (IndexedDB) - 支持搜索、更新、删除
- [x] ​**​编辑历史记录​**​ (自动保存，上限50条)
- [x] ​**​Markdown文件导入​**
- [x] ​**可配置的智能识别关联**：持续识别当前编辑是否为某个已保存文档的修改版。
    - [x] **关联强度与变更摘要显示**：实时预览区直观展示。
    - [x] **多种比较方式可选**：字符级、词语级、行级。
    - [x] **动态“恢复原始内容”按钮**：快速放弃对已加载文档的修改。
    - [x] **智能“另存为版本”建议**：当对已加载文档做较大修改时，保存弹窗会提示。
    - [x] **长文本性能优化**：可配置阈值，超长文本时可自动临时关闭智能识别，并有明确提示。
- [ ] **数据管理与同步**: 
	- [ ] **标签/文件夹组织**: 对于保存的文档，如果数量增多，可以引入标签或简单的文件夹系统进行分类管理。
	- [ ] **数据导出**: 导出当前所有`IndexedDB`数据，便于备份或迁移。
	- [ ] **数据导入**: 导入之前导出的数据，恢复之前保存的文档。
- [ ] **查找替换**: 快速替换匹配的文本，支持正则表达式。
- [ ] <span style="color: #A0A1A7;">更多功能敬请期待...</span>

## 使用指南 (含长文本优化)

1.  在左侧 **编辑器** 中输入或粘贴Markdown文本，或点击 **导入** 按钮加载本地 `.md` / `.txt` 文件。
2.  右侧将 **实时预览** 渲染后的效果。
3.  可配置 **智能识别关联** 功能（通过预览区右上角的开关，或编辑器上方的“关联设置”按钮进行调整）：
    *   开启此功能后，如果您修改了一个已加载的文档，只要新内容中还保留了足够多（达到您设定的“原文相似度要求”）的原文，系统就会认为您仍在编辑该文档的后续版本。
    *   **长文本处理** (可在“关联设置”中配置阈值和自动关闭行为)：
        *   当编辑器文本超过设定的“长文本阈值”时：
            *   若“长文本自动关闭智能识别”开启（默认），智能识别功能会**临时关闭**以保证流畅性，并有Toast提示。当文本长度恢复正常后，会自动重新开启。
            *   若此设置关闭，但智能识别仍开启，预览区“智能识别: 开启”旁会出现橙色“(长文本警告)”字样，提示您手动关闭以获得更佳性能。
            *   在进行智能识别计算前，若文本超长，会有Toast提示“正在进行长文本关联分析，请稍候...”。
    *   **预览区提示**：(当智能识别开启且未因长文本临时关闭时) 会显示关联强度（百分比）和简要的变更摘要。
    *   **“加载示例”按钮**：会变为“恢复原始内容”按钮，允许您一键放弃当前修改，并有二次确认。
    *   **导出文件名**：如果系统认为当前内容与某个已保存文档相关联，导出的文件名会优先使用那个已保存文档的名称。
    *   **保存弹窗**：
        *   如果系统认为当前内容与某个已保存文档相关联，当您点击“保存”时，会在列表中高亮显示那个已保存的文档。
        *   若修改较大，还会额外出现一个“另存为 [原文档名] v.日期时间”的按钮，方便您创建新版本。
4.  点击编辑器上方的 **保存** 按钮:
    *   在弹出窗口中点击 **另存为新...** 以创建新条目。
    *   点击列表中某一项旁的 **更新** 按钮以覆盖现有条目。
5.  点击编辑器上方的 **加载** 按钮:
    *   使用 **搜索框** 快速查找。
    *   点击列表中某一项旁的 **加载** 按钮将其内容填入编辑器（这将成为新的活动文档，智能识别功能会基于此文档进行判断）。
    *   点击 **删除** 按钮移除条目。
6.  点击编辑器上方的 **历史** 按钮:
    *   查看自动保存的编辑记录 (最近优先)。
    *   点击 **恢复** 将该版本内容加载到编辑器（这会清除活动文档状态，并重置智能识别的基准）。
    *   点击 **删除** 移除该条历史记录。
7.  在预览区上方选择 **导出格式** (HTML, 图片, PDF, DOCX, Markdown)，然后点击 **导出文件** 下载。 *PDF导出将保留视觉样式，但文本不可选。DOCX会尝试转换结构和基本样式。Markdown将导出纯文本。*

> 专业的技术文档与演示解决方案，提供更完善的本地管理和追溯功能！
```text
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
```
    </script>

    <script>
        // --- Global Variables & Constants ---
        const editor = document.getElementById('editor');
        const preview = document.getElementById('preview');
        const sampleContent = document.getElementById('sampleMarkdown').textContent.trim();
        const loadModal = document.getElementById('loadModal');
        const savedItemList = document.getElementById('savedItemList');
        const searchInput = document.getElementById('searchInput');
        const modalTitle = document.getElementById('modalTitle');
        const saveNewButton = document.getElementById('saveNewButton');
        const saveAsVersionButton = document.getElementById('saveAsVersionButton');
        const historyModal = document.getElementById('historyModal');
        const historyItemList = document.getElementById('historyItemList');
        const activeDocNameEl = document.getElementById('activeDocNameIndicator');
        const activeDocStatusEl = document.getElementById('activeDocStatusIndicator');
        const loadSampleOrRevertButton = document.getElementById('loadSampleOrRevertButton');
		const wordCountIndicator = document.getElementById('wordCountIndicator'); 

        const DB_NAME = 'markdownDB';
        const SAVED_STORE_NAME = 'savedMarkdown';
        const HISTORY_STORE_NAME = 'editHistory';
        const HISTORY_LIMIT = 50;
        let db;
        let historySaveTimeout;
        let lastSavedHistoryContent = null;
        let isSyncing = false;

        // --- Intelligent Association & Performance Variables ---
        let LONG_TEXT_THRESHOLD = 20000; // Default, will be loaded from localStorage
        let wasDiffTrackingEnabledBeforeLongText = null; 
        let isDiffTrackingEnabled = false;
        let diffAlgorithmType = 'chars'; 
        let diffDebounceTime = 1500; 
        let diffMatchThreshold = 0.85; 
        const SIGNIFICANT_MODIFICATION_THRESHOLD = 0.95;
        let jsdiffInstance = null; 
        let diffDebounceTimeout = null;
        let currentDiffAnalysisResult = { isRetained: false, rate: 0, diffs: [] };
        let activeSavedDocument = { id: null, name: null, originalContent: null };

        const diffConfigModal = document.getElementById('diffConfigModal');
        const diffAlgorithmSelect = document.getElementById('diffAlgorithmSelect');
        const diffDebounceTimeInput = document.getElementById('diffDebounceTimeInput');
        const diffMatchThresholdRange = document.getElementById('diffMatchThresholdRange');
        const diffMatchThresholdInput = document.getElementById('diffMatchThresholdInput');
        const diffTrackingToggle = document.getElementById('diffTrackingToggle');
        const diffStatusIndicator = document.getElementById('diffStatusIndicator');
        const trackingStrengthIndicator = document.getElementById('trackingStrengthIndicator');
        const changeSummaryIndicator = document.getElementById('changeSummaryIndicator');
        const longTextThresholdInput = document.getElementById('longTextThresholdInput');
        const autoDisableDiffForLongTextToggle = document.getElementById('autoDisableDiffForLongTextToggle');
        const longTextWarningSpan = document.getElementById('longTextWarning');
        const autoDisableDiffInfoSpan = document.getElementById('autoDisableDiffInfo');
        let previewUpdateDebounceTimeout;
        const DEBOUNCE_DELAY_PREVIEW = 250;
		
		// --- Function to calculate and update word count ---
		function updateWordCount() {
		    if (!editor || !wordCountIndicator) return;
		
		    const text = editor.value.trim();
		    let charCount = text.length;
		    
		    // Simple word count (splits by space/newline, filters empty strings)
		    // This is a basic count, can be more sophisticated for CJK, etc.
		    let wordCount = 0;
		    if (text) {
		        const words = text.split(/\s+/).filter(s => s.length > 0);
		        wordCount = words.length;
		    }
		
		    // For Chinese/Japanese/Korean (CJK) characters, often each char is a "word".
		    // A more robust CJK word count would require specific libraries or complex regex.
		    // Here's a very basic heuristic: count non-whitespace sequences and CJK chars.
		    let cjkWordCount = 0;
		    if (text) {
		        const cjkRegex = /[\u3000-\u303F\u3040-\u309F\u30A0-\u30FF\uFF00-\uFFEF\u4E00-\u9FAF\u3400-\u4DBF]/g;
		        const nonCjkWords = text.replace(cjkRegex, ' ').split(/\s+/).filter(s => s.length > 0);
		        const cjkChars = (text.match(cjkRegex) || []).length;
		        cjkWordCount = nonCjkWords.length + cjkChars;
		         // If primarily CJK, cjkWordCount might be more representative.
		        // For mixed, it's harder. Let's stick to simpler char/word count for now,
		        // or provide both if desired.
		    }
		
		    // Display format: "字符: X | 词语: Y"
		    // For simplicity, we'll show character count and a basic space-separated word count.
		    wordCountIndicator.textContent = `字符: ${charCount.toLocaleString()} | 词语: ${wordCount.toLocaleString()}`;
		    wordCountIndicator.title = `字符数: ${charCount.toLocaleString()}, 词语数 (按空格/换行分隔): ${wordCount.toLocaleString()}`;
		    wordCountIndicator.style.display = charCount > 0 ? 'inline' : 'none'; // Hide if empty
		}

        // --- Toast Notification ---
		function showToast(message, duration = 3000) {
		    document.querySelectorAll('.toast-message').forEach(t => t.remove());
            const toast = document.createElement('div');
            toast.textContent = message;
		    toast.className = 'toast-message';
		    document.body.appendChild(toast);
		    requestAnimationFrame(() => {
                requestAnimationFrame(() => { toast.classList.add('show'); });
            });
		    setTimeout(() => {
		        toast.classList.remove('show');
		        toast.addEventListener('transitionend', () => toast.remove());
		    }, duration);
		}

        // --- Editor & Indentation Logic ---
        editor.addEventListener('keydown', (e) => {
            if (e.key === 'Tab' && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
                e.preventDefault(); handleIndentation('indent');
            } else if (e.key === 'Tab' && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
                e.preventDefault(); handleIndentation('unindent');
            }
        });
        function handleIndentation(action) {
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const value = editor.value;
            const tab = '    ';
            if (start === end) {
                const lineStart = value.lastIndexOf('\n', start - 1) + 1;
                if (action === 'indent') {
                    editor.setRangeText(tab, start, start, 'end');
                } else {
                    const line = value.substring(lineStart, start);
                    if (line.startsWith(tab)) { editor.setRangeText('', lineStart, lineStart + tab.length, 'end'); }
                    else if (line.startsWith('\t')) { editor.setRangeText('', lineStart, lineStart + 1, 'end'); }
                    else {
                         const leadingSpaces = line.match(/^[ ]{1,4}/);
                         if (leadingSpaces) { editor.setRangeText('', lineStart, lineStart + leadingSpaces[0].length, 'end'); }
                    }
                }
            } else {
                const selectionLineStart = value.lastIndexOf('\n', start - 1) + 1;
                const textToModify = value.substring(selectionLineStart, end);
                let modifiedText = '';
                let lineShiftFirst = 0;
                const lines = textToModify.split('\n');
                lines.forEach((line, index) => {
                    let currentLineShift = 0;
                    if (action === 'indent') {
                        modifiedText += tab + line; currentLineShift = tab.length;
                    } else {
                        if (line.startsWith(tab)) { modifiedText += line.substring(tab.length); currentLineShift = -tab.length; }
                        else if (line.startsWith('\t')) { modifiedText += line.substring(1); currentLineShift = -1; }
                        else {
                             const leadingSpaces = line.match(/^[ ]{1,4}/);
                             if (leadingSpaces) { modifiedText += line.substring(leadingSpaces[0].length); currentLineShift = -leadingSpaces[0].length; }
                             else { modifiedText += line; }
                        }
                    }
                    if (index < lines.length - 1) { modifiedText += '\n'; }
                    if (index === 0) {
                         if (start > selectionLineStart) { lineShiftFirst = currentLineShift > 0 ? tab.length : Math.max(currentLineShift, -(start - selectionLineStart)); }
                         else { lineShiftFirst = currentLineShift; }
                    }
                });
                editor.setRangeText(modifiedText, selectionLineStart, end, 'select');
                const finalStart = Math.max(selectionLineStart, start + lineShiftFirst);
                const lengthDifference = modifiedText.length - textToModify.length;
                const finalEnd = end + lengthDifference;
                editor.setSelectionRange(finalStart, finalEnd);
            }
            requestPreviewUpdate(); 
            triggerHistorySave(); 
            checkAndManageDiffForLongText();
            handleContentChangeForAssociation(); 
            updateLoadSampleOrRevertButtonState();
        }


        // --- Core Editor and Preview Logic ---
        marked.setOptions({
            highlight: (code, lang) => {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                try {
                     if (language) { return hljs.highlight(code, { language, ignoreIllegals: true }).value; }
                } catch (e) { console.error(`Highlighting error for lang ${lang}:`, e); }
                try { return hljs.highlightAuto(code).value; }
                catch (autoError) {
                    console.error("Auto highlighting failed:", autoError);
                    const escapedCode = code.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    return `<pre><code class="hljs">${escapedCode}</code></pre>`;
                }
            },
            breaks: true, gfm: true
        });

        function handleLoadSampleOrRevert() {
            if (activeSavedDocument.id && editor.value !== activeSavedDocument.originalContent) {
                if (confirm(`确定要放弃当前对文档 "${activeSavedDocument.name}" 的更改，并恢复到原始内容吗？此操作无法撤销。`)) {
                    editor.value = activeSavedDocument.originalContent;
                    requestPreviewUpdate();
                    triggerHistorySave(); 
                    checkAndManageDiffForLongText();
                    handleContentChangeForAssociation(); 
                    updateLoadSampleOrRevertButtonState();
					updateWordCount();
                    showToast(`已恢复文档 "${activeSavedDocument.name}" 的原始内容。`);
                }
            } else {
                editor.value = sampleContent;
                requestPreviewUpdate();
                showToast("示例内容已加载");
                lastSavedHistoryContent = null; 
                clearActiveSavedDocumentState(true); 
                checkAndManageDiffForLongText(); // Check after loading sample
                updateLoadSampleOrRevertButtonState();
				updateWordCount();
            }
        }

        function updateLoadSampleOrRevertButtonState() {
            if (activeSavedDocument.id && activeSavedDocument.originalContent !== null && editor.value !== activeSavedDocument.originalContent) {
                loadSampleOrRevertButton.textContent = `恢复原始内容`;
                loadSampleOrRevertButton.title = `放弃当前修改，恢复到文档 "${activeSavedDocument.name}" 的原始内容`;
            } else {
                loadSampleOrRevertButton.textContent = '加载示例';
                loadSampleOrRevertButton.title = '加载内置的示例Markdown内容';
            }
        }

        function requestPreviewUpdate() {
            clearTimeout(previewUpdateDebounceTimeout);
            previewUpdateDebounceTimeout = setTimeout(() => {
                updatePreview();
            }, DEBOUNCE_DELAY_PREVIEW);
        }

        function updatePreview() { 
            try {
                 preview.innerHTML = marked.parse(editor.value);
                 hljs.highlightAll();
            } catch (e) {
                 console.error("Markdown Parsing Error:", e);
                 preview.innerHTML = `<p style="color: red;">Error parsing Markdown. Check console for details.</p>`;
            }
        }


        // --- File Import Logic ---
        function importMarkdownFile() { 
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.md,.txt,text/markdown,text/plain';
            fileInput.onchange = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        editor.value = e.target.result;
                        requestPreviewUpdate();
                        triggerHistorySave();
                        showToast(`文件 "${file.name}" 已导入！`);
                        clearActiveSavedDocumentState(true); 
                        checkAndManageDiffForLongText();
                        updateLoadSampleOrRevertButtonState();
						updateWordCount();
                    };
                    reader.onerror = (e) => { console.error("File reading error:", e); showToast("文件读取失败。"); };
                    reader.readAsText(file);
                }
            };
            fileInput.click();
        }

        // --- Export Logic ---
        async function exportFile(event) {
            const format = document.getElementById('format').value;
            const markdownInput = editor.value;
            const exportButton = event.target;
            const originalButtonText = exportButton.textContent;

            exportButton.disabled = true;
            exportButton.textContent = '导出中...';

            const baseFilename = generateBaseFilename(); 
            let filenameWithExt = `${baseFilename}.txt`; 

            if (format === 'markdown') {
                try {
                    filenameWithExt = `${baseFilename}.md`;
                    triggerDownload(
                        URL.createObjectURL(new Blob([markdownInput], { type: 'text/markdown;charset=UTF-8' })),
                        filenameWithExt
                    );
                    showToast('Markdown 文件导出成功！');
                } catch (error) {
                    showToast(`导出失败: ${error.message}`);
                    console.error("Export Error (Markdown):", error);
                } finally {
                    exportButton.disabled = false;
                    exportButton.textContent = originalButtonText;
                }
                return;
            }

            // For non-markdown formats, ensure preview is up-to-date before capture
            // This is a synchronous update for export, could be slow for very large docs
            try {
                preview.innerHTML = marked.parse(markdownInput);
                hljs.highlightAll();
            } catch (e) {
                showToast(`Markdown 解析错误，无法导出: ${e.message}`);
                exportButton.disabled = false;
                exportButton.textContent = originalButtonText;
                return;
            }


            const previewElement = document.getElementById('preview');
            // try { // This was already done above, removed redundant parsing
            //     previewElement.innerHTML = marked.parse(markdownInput);
            //     hljs.highlightAll();
            // } catch (e) {
            //     showToast(`Markdown 解析错误，无法导出: ${e.message}`);
            //     exportButton.disabled = false;
            //     exportButton.textContent = originalButtonText;
            //     return;
            // }

            const captureContainer = document.createElement('div');
            captureContainer.className = 'markdown-body';
            Object.assign(captureContainer.style, {
                position: 'absolute', left: '-9999px', top: '0px',
                padding: '2rem', background: 'var(--preview-bg)',
                width: previewElement.scrollWidth + 'px',
                minWidth: '600px', height: 'auto', overflow: 'visible',
                boxSizing: 'content-box'
            });
            const clonedPreview = previewElement.cloneNode(true);
            captureContainer.appendChild(clonedPreview);
            document.body.appendChild(captureContainer);

            await new Promise(resolve => requestAnimationFrame(resolve));
            await new Promise(resolve => setTimeout(resolve, 150));

            try {
                switch(format) {
                    case 'image':
                    case 'pdf':
                        const scale = window.devicePixelRatio || 2;
                        const canvas = await html2canvas(captureContainer, {
                            scale: scale, useCORS: true, logging: false, scrollX: 0, scrollY: 0,
                            windowWidth: captureContainer.scrollWidth,
                            windowHeight: captureContainer.scrollHeight,
                            backgroundColor: getComputedStyle(captureContainer).backgroundColor
                        });
                        if (format === 'image') {
                            filenameWithExt = `${baseFilename}.png`;
                            triggerDownload(canvas.toDataURL('image/png'), filenameWithExt);
                            showToast('图片导出成功！');
                        } else {
                            filenameWithExt = `${baseFilename}.pdf`;
                            const { jsPDF } = window.jspdf;
                            const imgData = canvas.toDataURL('image/png');
                            const imgProps = { width: canvas.width / scale, height: canvas.height / scale };
                            const pdf = new jsPDF({
                                orientation: imgProps.width > imgProps.height ? 'l' : 'p',
                                unit: 'px',
                                format: [imgProps.width, imgProps.height]
                            });
                            const pdfWidth = pdf.internal.pageSize.getWidth();
                            const pdfHeight = pdf.internal.pageSize.getHeight();
                            const ratio = Math.min(pdfWidth / imgProps.width, pdfHeight / imgProps.height);
                            pdf.addImage(imgData, 'PNG', (pdfWidth - imgProps.width * ratio) / 2, 0, imgProps.width * ratio, imgProps.height * ratio);
                            pdf.save(filenameWithExt);
                            showToast('PDF导出成功！(作为单页图片)');
                        }
                        break;
                    case 'html':
                        filenameWithExt = `${baseFilename}.html`;
                        const fullHTML = createFullHtml(clonedPreview.innerHTML);
                        triggerDownload(
                            URL.createObjectURL(new Blob([fullHTML], { type: 'text/html;charset=UTF-8' })),
                            filenameWithExt
                        );
                        showToast('HTML导出成功！');
                        break;
                    case 'docx':
                        filenameWithExt = `${baseFilename}.docx`;
                        const docxHtmlString = createFullHtml(clonedPreview.innerHTML);
                        if (typeof htmlDocx === 'undefined') throw new Error("html-docx-js library not loaded.");
                        const fileBlob = htmlDocx.asBlob(docxHtmlString);
                        triggerDownload(URL.createObjectURL(fileBlob), filenameWithExt);
                        showToast('DOCX导出成功！');
                        break;
                }
            } catch (error) {
                showToast(`导出失败: ${error.message}`);
                console.error("Export Error:", error);
            } finally {
                if (document.body.contains(captureContainer)) document.body.removeChild(captureContainer);
                exportButton.disabled = false;
                exportButton.textContent = originalButtonText;
            }
        }

        function createFullHtml(bodyContent) { 
            return `
                <!DOCTYPE html>
                <html lang="zh-CN" xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
                <head>
                    <meta charset="UTF-8">
                    <title>Exported Markdown</title>
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css">
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.css">
                    <style>
                        body { font-family: Calibri, sans-serif; font-size: 11pt; padding: 1in; margin: 0; }
                        .markdown-body { }
                        pre { background-color: #f6f8fa; border: 1px solid #e1e4e8; padding: 1em; overflow: auto; font-family: Consolas, monospace; }
                        code { font-family: Consolas, monospace; font-size: 90%; }
                        table { border-collapse: collapse; width: 100%; }
                        th, td { border: 1px solid #dfe2e5; padding: 6px 13px; }
                        blockquote { border-left: .25em solid #dfe2e5; color: #6a737d; padding: 0 1em; margin-left: 0; }
                        :root { --preview-bg: #ffffff; --border-color: #e1e4e8; }
                    </style>
                     <!--[if gte mso 9]>
                     <xml>
                         <w:WordDocument>
                         <w:View>Print</w:View>
                         <w:Zoom>100</w:Zoom>
                         <w:DoNotOptimizeForBrowser/>
                         </w:WordDocument>
                     </xml>
                     <![endif]-->
                </head>
                <body>
                    <div class="markdown-body">
                        ${bodyContent}
                    </div>
                 </body>
                </html>
            `;
        }
        function triggerDownload(dataURL, filename) { 
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            if (dataURL.startsWith('blob:')) {
                setTimeout(() => URL.revokeObjectURL(dataURL), 100);
            }
        }

        // --- IndexedDB Logic ---
        function initDB() { 
            return new Promise((resolve, reject) => {
                if (db) return resolve(db);
                const request = indexedDB.open(DB_NAME, 2); 
                request.onerror = (event) => reject("Database error: " + event.target.error);
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("Database opened successfully (v2)");
                     getLastHistoryEntryContent().then(content => {
                         lastSavedHistoryContent = content;
                     }).catch(err => console.error("Error getting initial last history entry:", err));
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    console.log("Database upgrade needed");
                    const tempDb = event.target.result;
                    if (!tempDb.objectStoreNames.contains(SAVED_STORE_NAME)) {
                        const savedStore = tempDb.createObjectStore(SAVED_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        savedStore.createIndex('name', 'name', { unique: false });
                        savedStore.createIndex('timestamp', 'timestamp', { unique: false });
                        console.log("Object store 'savedMarkdown' created");
                    }
                    if (!tempDb.objectStoreNames.contains(HISTORY_STORE_NAME)) {
                        const historyStore = tempDb.createObjectStore(HISTORY_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        historyStore.createIndex('timestamp', 'timestamp', { unique: false });
                        console.log("Object store 'editHistory' created");
                    }
                };
            });
        }
        async function saveMarkdown(name, content) { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const timestamp = new Date();
                const request = store.add({ name, content, timestamp });
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result); 
                    request.onerror = (event) => reject("Error saving: " + event.target.error);
                    transaction.onerror = (event) => reject("Save transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`保存失败: ${error}`); throw error; }
        }
        async function updateMarkdown(id, name, content) { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const timestamp = new Date();
                const request = store.put({ id, name, content, timestamp });
                 return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(id);
                    request.onerror = (event) => reject("Error updating: " + event.target.error);
                    transaction.onerror = (event) => reject("Update transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`更新失败: ${error}`); throw error; }
        }
        async function loadAllMarkdown() { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readonly');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const index = store.index('timestamp');
                const request = index.getAll();
                 return new Promise((resolve, reject) => {
                     request.onsuccess = () => {
                         const sortedResults = request.result.sort((a, b) => b.timestamp - a.timestamp);
                         resolve(sortedResults);
                     };
                     request.onerror = (event) => reject("Error loading all: " + event.target.error);
                     transaction.onerror = (event) => reject("Load all transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`加载列表失败: ${error}`); return []; }
        }
        async function loadMarkdownById(id) { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readonly');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const request = store.get(id);
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject("Error loading by ID: " + event.target.error);
                     transaction.onerror = (event) => reject("Load ID transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`加载文档失败: ${error}`); return null; }
        }
        async function deleteMarkdownById(id) { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const request = store.delete(id);
                 return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => reject("Error deleting: " + event.target.error);
                     transaction.onerror = (event) => reject("Delete transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`删除失败: ${error}`); return false; }
        }

        // --- EDIT HISTORY Logic ---
        function scheduleHistorySave() { clearTimeout(historySaveTimeout); historySaveTimeout = setTimeout(saveCurrentStateToHistory, 2000); }
        function triggerHistorySave() { clearTimeout(historySaveTimeout); setTimeout(saveCurrentStateToHistory, 0); }
        async function saveCurrentStateToHistory() {
            const content = editor.value;
            if (content === sampleContent && !activeSavedDocument.id) return;
            if (!content.trim() || content === lastSavedHistoryContent) return;
            try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const request = store.add({ content, timestamp: new Date() });
                request.onsuccess = (e) => {
                    lastSavedHistoryContent = content; 
                    pruneHistory();
                };
                request.onerror = (event) => console.error("Error saving history entry:", event.target.error);
                transaction.onerror = (event) => console.error("History save transaction error:", event.target.error);
            } catch (error) { console.error("Failed to initiate history save:", error); }
        }
        async function pruneHistory() { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const countRequest = store.count();
                countRequest.onsuccess = () => {
                    const count = countRequest.result;
                    if (count > HISTORY_LIMIT) {
                        const itemsToDelete = count - HISTORY_LIMIT;
                        let deletedCount = 0;
                        const index = store.index('timestamp'); 
                        const cursorRequest = index.openCursor(null, 'next'); 
                        cursorRequest.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor && deletedCount < itemsToDelete) {
                                cursor.delete(); 
                                deletedCount++; 
                                cursor.continue();
                            } else { 
                                if (deletedCount > 0) console.log(`Pruning complete. Deleted ${deletedCount} entries.`);
                            }
                        };
                        cursorRequest.onerror = (event) => console.error("Error opening cursor for pruning:", event.target.error);
                    }
                };
                countRequest.onerror = (event) => console.error("Error counting history items:", event.target.error);
                 transaction.onerror = (event) => console.error("History prune transaction error:", event.target.error);
            } catch (error) { console.error("Failed to initiate history pruning:", error); }
        }
        async function loadAllHistory() { 
            try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readonly');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const index = store.index('timestamp');
                const request = index.getAll();
                return new Promise((resolve, reject) => {
                     request.onsuccess = () => {
                         const sortedResults = request.result.sort((a, b) => b.timestamp - a.timestamp); 
                         resolve(sortedResults);
                     };
                     request.onerror = (event) => reject("Error loading history: " + event.target.error);
                     transaction.onerror = (event) => reject("Load history transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`加载历史失败: ${error}`); return []; }
        }
        async function loadHistoryById(id) { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readonly');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const request = store.get(id);
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject("Error loading history ID: " + event.target.error);
                     transaction.onerror = (event) => reject("Load history ID transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`加载历史条目失败: ${error}`); return null; }
        }
        async function deleteHistoryById(id) { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const request = store.delete(id);
                 return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => reject("Error deleting history: " + event.target.error);
                     transaction.onerror = (event) => reject("Delete history transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`删除历史失败: ${error}`); return false; }
        }
         async function getLastHistoryEntryContent() { 
             return new Promise(async (resolve, reject) => {
                 try {
                    const dbInstance = await initDB();
                    const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(HISTORY_STORE_NAME);
                    const index = store.index('timestamp');
                    const cursorRequest = index.openCursor(null, 'prev'); 
                    cursorRequest.onsuccess = (event) => {
                        const cursor = event.target.result;
                        resolve(cursor ? cursor.value.content : null);
                    };
                    cursorRequest.onerror = (event) => reject("Error getting last history entry: " + event.target.error);
                    transaction.onerror = (event) => reject("Last history transaction error: " + event.target.error);
                 } catch (error) { reject("Failed to initiate get last history: " + error); }
             });
         }


        // --- Intelligent Association & Performance Logic ---
        function loadDiffSettings() {
            isDiffTrackingEnabled = localStorage.getItem('diffTrackingEnabled') === 'true';
            diffAlgorithmType = localStorage.getItem('diffAlgorithmType') || 'chars';
            diffDebounceTime = parseInt(localStorage.getItem('diffDebounceTime'), 10) || 1500;
            if (diffDebounceTime < 1000) diffDebounceTime = 1000;
            diffMatchThreshold = parseFloat(localStorage.getItem('diffMatchThreshold')) || 0.85; 
            if (diffMatchThreshold < 0.5) diffMatchThreshold = 0.5;
            if (diffMatchThreshold > 1.0) diffMatchThreshold = 1.0;
            
            LONG_TEXT_THRESHOLD = parseInt(localStorage.getItem('longTextThreshold'), 10) || 20000;
            if (LONG_TEXT_THRESHOLD < 5000) LONG_TEXT_THRESHOLD = 5000;
            const autoDisable = localStorage.getItem('autoDisableDiffForLongText');
            autoDisableDiffForLongTextToggle.checked = autoDisable === null ? true : (autoDisable === 'true');


            diffTrackingToggle.checked = isDiffTrackingEnabled;
            diffAlgorithmSelect.value = diffAlgorithmType;
            diffDebounceTimeInput.value = diffDebounceTime;
            diffMatchThresholdInput.value = Math.round(diffMatchThreshold * 100); 
            diffMatchThresholdRange.value = Math.round(diffMatchThreshold * 100); 
            longTextThresholdInput.value = LONG_TEXT_THRESHOLD;
            updateAutoDisableDiffInfoSpan();
            updateDiffStatusIndicator();
        }

        function saveDiffSettings() {
            localStorage.setItem('diffTrackingEnabled', isDiffTrackingEnabled);
            localStorage.setItem('diffAlgorithmType', diffAlgorithmType);
            localStorage.setItem('diffDebounceTime', diffDebounceTime);
            localStorage.setItem('diffMatchThreshold', diffMatchThreshold); 
            localStorage.setItem('longTextThreshold', LONG_TEXT_THRESHOLD);
            localStorage.setItem('autoDisableDiffForLongText', autoDisableDiffForLongTextToggle.checked);
        }
        
        function updateAutoDisableDiffInfoSpan() {
             if(autoDisableDiffInfoSpan) autoDisableDiffInfoSpan.textContent = `超过 ${LONG_TEXT_THRESHOLD.toLocaleString()} 字符时临时关闭`;
        }

        function checkAndManageDiffForLongText() {
            const currentContentLength = editor.value.length;
            const autoDisableSetting = autoDisableDiffForLongTextToggle.checked;

            if (currentContentLength > LONG_TEXT_THRESHOLD) {
                if (isDiffTrackingEnabled) { 
                    if (wasDiffTrackingEnabledBeforeLongText === null) { 
                        wasDiffTrackingEnabledBeforeLongText = true; 
                    }

                    if (autoDisableSetting) { 
                        isDiffTrackingEnabled = false; 
                        diffTrackingToggle.checked = false; 
                        updateDiffStatusIndicator(); 
                        showToast("检测到长文本，为保持流畅，智能识别已临时关闭。", 4000);
                    } else {
                        updateLongTextWarningUI(true);
                         // No separate toast here, the pre-computation toast in handleContentChangeForAssociation will cover it.
                    }
                }
            } else { 
                if (wasDiffTrackingEnabledBeforeLongText === true) { 
                    isDiffTrackingEnabled = true; 
                    diffTrackingToggle.checked = true;
                    updateDiffStatusIndicator();
                    showToast("文本长度恢复，智能识别已自动重新开启。", 3000);
                    wasDiffTrackingEnabledBeforeLongText = null; 
                }
                updateLongTextWarningUI(false); 
            }
        }

        function updateLongTextWarningUI(show) {
            if (longTextWarningSpan) {
                longTextWarningSpan.textContent = show ? '(长文本警告)' : '';
                longTextWarningSpan.style.display = show ? 'inline' : 'none';
            }
        }


        function updateDiffStatusIndicator() {
            if (!jsdiffInstance) { 
                diffStatusIndicator.textContent = '智能识别: 不可用';
                diffStatusIndicator.classList.remove('enabled');
                diffStatusIndicator.classList.add('disabled');
                diffTrackingToggle.checked = false;
                diffTrackingToggle.disabled = true;
                trackingStrengthIndicator.style.display = 'none';
                changeSummaryIndicator.style.display = 'none';
                updateLongTextWarningUI(false);
                return;
            }

            if (isDiffTrackingEnabled) {
                diffStatusIndicator.textContent = '智能识别: 开启';
                diffStatusIndicator.classList.remove('disabled');
                diffStatusIndicator.classList.add('enabled');
                // Warning for long text is handled by checkAndManageDiffForLongText -> updateLongTextWarningUI
            } else {
                diffStatusIndicator.textContent = '智能识别: 关闭';
                diffStatusIndicator.classList.remove('enabled');
                diffStatusIndicator.classList.add('disabled');
                currentDiffAnalysisResult.isRetained = false; 
                updateLongTextWarningUI(false); // Hide warning if globally disabled
            }
            updateActiveDocIndicators(); 
        }

        diffTrackingToggle.addEventListener('change', (event) => {
            isDiffTrackingEnabled = event.target.checked;
            // If user manually enables it, reset the "auto-disabled" state
            if (isDiffTrackingEnabled) {
                wasDiffTrackingEnabledBeforeLongText = null; 
            }
            saveDiffSettings(); // Save the global enabled/disabled state
            updateDiffStatusIndicator();
            showToast(`智能识别关联功能已${isDiffTrackingEnabled ? '开启' : '关闭'}`);
            
            checkAndManageDiffForLongText(); // Re-check long text condition after manual toggle

            if (isDiffTrackingEnabled && activeSavedDocument.id) {
                handleContentChangeForAssociation(); 
            } else {
                currentDiffAnalysisResult.isRetained = false; 
                updateActiveDocIndicators();
            }
        });

        function showDiffConfigModal() {
            longTextThresholdInput.value = LONG_TEXT_THRESHOLD;
            autoDisableDiffForLongTextToggle.checked = localStorage.getItem('autoDisableDiffForLongText') === null ? true : (localStorage.getItem('autoDisableDiffForLongText') === 'true');
            updateAutoDisableDiffInfoSpan(); // Update text with current threshold

            diffAlgorithmSelect.value = diffAlgorithmType;
            diffAlgorithmSelect.disabled = !jsdiffInstance;
            diffDebounceTimeInput.value = diffDebounceTime;
            const thresholdPercent = Math.round(diffMatchThreshold * 100);
            diffMatchThresholdInput.value = thresholdPercent;
            diffMatchThresholdRange.value = thresholdPercent;
            diffConfigModal.style.display = 'flex';
			diffConfigModal.classList.add('show-flex'); 
        }
        function hideDiffConfigModal() { 
			diffConfigModal.style.display = 'none'; 
			diffConfigModal.classList.remove('show-flex');
		}

        diffMatchThresholdRange.addEventListener('input', (e) => {
            diffMatchThresholdInput.value = e.target.value;
        });
        diffMatchThresholdInput.addEventListener('input', (e) => {
            let val = parseInt(e.target.value, 10);
            if (val < 50) val = 50;
            if (val > 100) val = 100;
            e.target.value = val; 
            diffMatchThresholdRange.value = val;
        });


        function handleSaveDiffSettings() {
            const newLongTextThreshold = parseInt(longTextThresholdInput.value, 10);
            if (newLongTextThreshold >= 5000) {
                LONG_TEXT_THRESHOLD = newLongTextThreshold;
            } else {
                showToast("长文本阈值不能小于5000字符。", 3000);
                longTextThresholdInput.value = LONG_TEXT_THRESHOLD; // Revert to old value
                return; // Early exit
            }
            updateAutoDisableDiffInfoSpan(); // Update text with new threshold immediately

            // Auto-disable toggle is directly saved via its 'checked' state later
            // diffAlgorithmType, diffDebounceTime, diffMatchThreshold are saved as before
            const newAlgoType = diffAlgorithmSelect.value;
            diffAlgorithmType = newAlgoType;

            const newDebounceTime = parseInt(diffDebounceTimeInput.value, 10);
            if (newDebounceTime >= 1000) {
                diffDebounceTime = newDebounceTime;
            } else {
                showToast("内容更新检测延迟不能小于1000毫秒 (即1秒)", 3000);
                diffDebounceTimeInput.value = diffDebounceTime; 
                return;
            }

            const newThresholdPercent = parseInt(diffMatchThresholdInput.value, 10);
            if (newThresholdPercent >= 50 && newThresholdPercent <= 100) {
                diffMatchThreshold = newThresholdPercent / 100; 
            } else {
                showToast("原文相似度要求必须在50%到100%之间", 3000);
                diffMatchThresholdInput.value = Math.round(diffMatchThreshold * 100); 
                diffMatchThresholdRange.value = Math.round(diffMatchThreshold * 100);
                return;
            }

            saveDiffSettings(); // This will now also save longTextThreshold and autoDisable toggle state
            hideDiffConfigModal();
            showToast("智能识别设置已保存！");
            
            checkAndManageDiffForLongText(); // Re-evaluate with new settings
            if (isDiffTrackingEnabled && activeSavedDocument.id) { // If still enabled after check
                 handleContentChangeForAssociation(); 
            }
        }
        
        function analyzeContentDifference(originalText, currentText, threshold, algorithm) {
            if (!jsdiffInstance) {
                return { isRetained: (originalText === currentText), rate: (originalText === currentText ? 1 : 0), diffs: [] };
            }
            if (originalText === null || originalText === undefined) originalText = "";
            if (currentText === null || currentText === undefined) currentText = "";

            const countCharsRobust = (text) => text.length;
            const countWordsRobust = (text) => text.split(/\s+/).filter(Boolean).length;
            const countLinesRobust = (text) => (text === "" ? 0 : text.split('\n').length);

            let currentUnitCountFunc;
            switch (algorithm) {
                case 'words': currentUnitCountFunc = countWordsRobust; break;
                case 'lines': currentUnitCountFunc = countLinesRobust; break;
                default: currentUnitCountFunc = countCharsRobust; break;
            }
            
            if (originalText === "") { 
                const currentLengthInUnits = currentUnitCountFunc(currentText);
                return { 
                    isRetained: (currentLengthInUnits === 0), 
                    rate: (currentLengthInUnits === 0 ? 1 : 0), 
                    diffs: (currentLengthInUnits > 0 ? [{ added: true, value: currentText, count: currentLengthInUnits }] : [])
                };
            }
            if (originalText === currentText) {
                return { 
                    isRetained: true, 
                    rate: 1, 
                    diffs: [{ value: originalText, count: currentUnitCountFunc(originalText) }] 
                };
            }

            let diffs;
            switch (algorithm) {
                case 'words': diffs = jsdiffInstance.diffWords(originalText, currentText); break;
                case 'lines': diffs = jsdiffInstance.diffLines(originalText, currentText, { newlineIsToken: true }); break;
                default: diffs = jsdiffInstance.diffChars(originalText, currentText); break;
            }
            
            const originalLengthInUnits = currentUnitCountFunc(originalText);
            let commonCountInUnits = 0;
            diffs.forEach(part => {
                if (!part.added && !part.removed && part.value) {
                    commonCountInUnits += currentUnitCountFunc(part.value);
                }
            });
            
            let retentionRate = 0;
            if (originalLengthInUnits > 0) {
                retentionRate = commonCountInUnits / originalLengthInUnits;
            } else if (commonCountInUnits === 0) { 
                retentionRate = 1; 
            }
            const finalRate = Math.min(retentionRate, 1.0);
            return {
                isRetained: finalRate >= threshold,
                rate: finalRate,
                diffs: diffs
            };
        }

        function handleContentChangeForAssociation() {
            if (!activeSavedDocument.id || activeSavedDocument.originalContent === null) {
                currentDiffAnalysisResult = { isRetained: false, rate: 0, diffs: [] };
                updateActiveDocIndicators();
                return;
            }
            clearTimeout(diffDebounceTimeout);
            diffDebounceTimeout = setTimeout(() => {
                if (!isDiffTrackingEnabled) { // Check if it was auto-disabled or manually
                    currentDiffAnalysisResult = { isRetained: false, rate: 0, diffs: [] }; 
                    updateActiveDocIndicators();
                    return;
                }
                const currentContent = editor.value;
                if (currentContent.length > LONG_TEXT_THRESHOLD && 
                    (!autoDisableDiffForLongTextToggle.checked || wasDiffTrackingEnabledBeforeLongText === null) ) { // Show toast if not auto-disabled or if it's the first calc on long text
                    showToast("正在进行长文本关联分析，请稍候...", 2000);
                }
                currentDiffAnalysisResult = analyzeContentDifference(
                    activeSavedDocument.originalContent,
                    currentContent,
                    diffMatchThreshold,
                    diffAlgorithmType
                );
                updateActiveDocIndicators();
            }, diffDebounceTime);
        }
        
        function calculateDiffSummary(diffs, algorithm) {
            if (!diffs || diffs.length === 0) return "";
            let added = 0;
            let removed = 0;
            let unit = "字";

            const countCharsRobust = (text) => text.length;
            const countWordsRobust = (text) => text.split(/\s+/).filter(Boolean).length;
            const countLinesRobust = (text) => (text === "" ? 0 : text.split('\n').length);
            let currentUnitCountFunc;

            if (algorithm === 'lines') {
                unit = "行"; currentUnitCountFunc = countLinesRobust;
                diffs.forEach(part => { // jsdiff for lines with newlineIsToken often gives reliable 'count'
                    if (part.added) added += (part.count || currentUnitCountFunc(part.value));
                    else if (part.removed) removed += (part.count || currentUnitCountFunc(part.value));
                });
            } else {
                 if (algorithm === 'words') { unit = "词"; currentUnitCountFunc = countWordsRobust; }
                 else { unit = "字"; currentUnitCountFunc = countCharsRobust; }
                 diffs.forEach(part => {
                    if (part.added) added += currentUnitCountFunc(part.value);
                    else if (part.removed) removed += currentUnitCountFunc(part.value);
                });
            }
            
            let summaryText = "";
            if (added > 0) summaryText += `+${added}${unit} `;
            if (removed > 0) summaryText += `-${removed}${unit}`;
            return summaryText.trim();
        }


        // --- Active Saved Document State ---
        function setActiveSavedDocumentState(id, name, content) {
            activeSavedDocument.id = id;
            activeSavedDocument.name = name;
            activeSavedDocument.originalContent = content; 
            currentDiffAnalysisResult = { isRetained: true, rate: 1.0, diffs: [] };
            updateActiveDocIndicators();
            updateLoadSampleOrRevertButtonState();
            checkAndManageDiffForLongText(); // Check long text status for the new active doc
            console.log(`Active document set: ID ${id}, Name "${name}"`);
        }

        function clearActiveSavedDocumentState(isDestructiveLoad = false) {
            if (activeSavedDocument.id !== null) {
                 console.log(`Active document cleared. Was: ID ${activeSavedDocument.id}, Name "${activeSavedDocument.name}"`);
            }
            activeSavedDocument.id = null;
            activeSavedDocument.name = null;
            activeSavedDocument.originalContent = null;
            currentDiffAnalysisResult = { isRetained: false, rate: 0, diffs: [] };
            updateActiveDocIndicators();
            updateLoadSampleOrRevertButtonState();
            checkAndManageDiffForLongText(); // Re-evaluate long text for empty/sample state
			updateWordCount();
        }
        
        function updateActiveDocIndicators() {
            const { isRetained, rate, diffs } = currentDiffAnalysisResult;
            if (activeSavedDocument.id && activeSavedDocument.name) {
                activeDocNameEl.textContent = escapeHtml(truncateText(activeSavedDocument.name, 20));
                activeDocNameEl.title = `当前编辑基于文档: ${escapeHtml(activeSavedDocument.name)}`;
                let statusText = "";
                let statusTitle = "";
                if (isDiffTrackingEnabled) { 
                    if (editor.value === activeSavedDocument.originalContent) {
                        statusText = "(原始内容)"; statusTitle = "内容与已保存的原始版本一致";
                    } else if (isRetained) {
                        statusText = "(识别为修改版)"; statusTitle = `内容已修改，但系统仍认为与原文档 "${escapeHtml(activeSavedDocument.name)}" 相关联 (相似度: ${Math.round(rate * 100)}%)`;
                    } else {
                        statusText = "(关联度低)"; statusTitle = `内容与原文档 "${escapeHtml(activeSavedDocument.name)}" 差异较大 (相似度: ${Math.round(rate * 100)}%)，系统不再认为它们强相关`;
                    }
                } else { 
                    if (activeSavedDocument.originalContent !== null && editor.value !== activeSavedDocument.originalContent) {
                         statusText = "(已修改)"; statusTitle = `内容已修改 (智能识别已关闭${wasDiffTrackingEnabledBeforeLongText ? ' - 因长文本临时关闭':''})`;
                    } else if (activeSavedDocument.originalContent !== null && editor.value === activeSavedDocument.originalContent) {
                        statusText = "(原始内容)"; statusTitle = "内容与已保存的原始版本一致 (智能识别已关闭)";
                    } else if (wasDiffTrackingEnabledBeforeLongText) { // Diff is off, but was auto-disabled
                         statusText = ""; statusTitle = `智能识别已因长文本临时关闭`;
                    }
                }
                activeDocStatusEl.textContent = statusText;
                activeDocStatusEl.title = statusTitle;
            } else {
                activeDocNameEl.textContent = ''; activeDocNameEl.title = '';
                activeDocStatusEl.textContent = ''; activeDocStatusEl.title = '';
            }

            if (isDiffTrackingEnabled && activeSavedDocument.id && jsdiffInstance) {
                trackingStrengthIndicator.textContent = `${Math.round(rate * 100)}%`;
                trackingStrengthIndicator.className = isRetained ? 'strong' : 'weak';
                trackingStrengthIndicator.style.display = 'inline-block';
                if (editor.value !== activeSavedDocument.originalContent) {
                    changeSummaryIndicator.textContent = calculateDiffSummary(diffs, diffAlgorithmType);
                    changeSummaryIndicator.style.display = changeSummaryIndicator.textContent ? 'inline-block' : 'none';
                } else {
                    changeSummaryIndicator.style.display = 'none';
                }
            } else {
                trackingStrengthIndicator.style.display = 'none';
                changeSummaryIndicator.style.display = 'none';
            }
        }


        // --- UI Interaction for Modals ---
        function showLoadModal() { populateModal(false); }
        function showSaveModal() { populateModal(true); }
        function hideLoadModal() { loadModal.style.display = 'none'; }

        async function populateModal(isSavingMode = false) {
            modalTitle.textContent = isSavingMode ? "保存或更新 Markdown" : "加载已保存的 Markdown";
            saveNewButton.style.display = isSavingMode ? 'inline-flex' : 'none';
            saveAsVersionButton.style.display = 'none'; 
            searchInput.value = '';
            try {
                const items = await loadAllMarkdown();
                savedItemList.innerHTML = ''; 
                const noItemsLi = '<li class="no-items">没有找到已保存的文档。</li>';
                if (isSavingMode) {
                    const { isRetained, rate } = currentDiffAnalysisResult;
                    if (isDiffTrackingEnabled && isRetained && activeSavedDocument.id && activeSavedDocument.name && rate < SIGNIFICANT_MODIFICATION_THRESHOLD && editor.value !== activeSavedDocument.originalContent) {
                        saveAsVersionButton.textContent = `另存为 "${truncateText(activeSavedDocument.name, 15)} v.${getTimestampForFilename(true)}"`;
                        saveAsVersionButton.style.display = 'inline-flex';
                    }
                }
                if (items && items.length > 0) {
                    let activeItemElement = null;
                    items.forEach(item => {
                        const li = document.createElement('li');
                        li.className = 'saved-item';
                        li.dataset.id = item.id; li.dataset.name = item.name;
                        li.innerHTML = `
                            <div class="item-info">
                                <span class="item-name" title="${escapeHtml(item.name)}">${escapeHtml(item.name)}</span>
                                <span class="item-timestamp">保存于: ${formatTimestamp(item.timestamp)}</span>
                            </div>
                            <div class="item-actions">
                                ${isSavingMode ? `<button class="small" onclick="handleUpdateItem(event, ${item.id})" title="使用当前编辑器内容覆盖此项">更新</button>` : ''}
                                <button class="small" onclick="handleLoadItem(${item.id})" title="加载此项到编辑器">加载</button>
                                <button class="small danger" onclick="handleDeleteItem(event, ${item.id}, 'saved')" title="删除此项">删除</button>
                            </div>`;
                        savedItemList.appendChild(li);
                        if (isSavingMode && isDiffTrackingEnabled && currentDiffAnalysisResult.isRetained &&
                            activeSavedDocument.id === item.id) {
                            li.classList.add('highlighted-active-doc');
                            activeItemElement = li;
                        }
                    });
                    if (activeItemElement) {
                        loadModal.style.display = 'flex'; 
						loadModal.classList.add('show-flex');
                        requestAnimationFrame(() => { 
                             activeItemElement.scrollIntoView({ behavior: 'auto', block: 'center', inline: 'nearest' });
                        });
                    } else {
                         loadModal.style.display = 'flex';
						 loadModal.classList.add('show-flex');
                    }
                } else {
                    savedItemList.innerHTML = noItemsLi;
                    loadModal.style.display = 'flex';
					loadModal.classList.add('show-flex');
                }
                filterSavedItems();
            } catch (error) {
                showToast(`加载列表失败: ${error}`);
                savedItemList.innerHTML = '<li class="no-items" style="color:red;">加载列表时出错。</li>';
                loadModal.style.display = 'flex';
				loadModal.classList.add('show-flex');
            }
        }
        function filterSavedItems() { 
            const filter = searchInput.value.toLowerCase();
            const items = savedItemList.querySelectorAll('li.saved-item');
            let visibleCount = 0;
            const noItemsMessage = savedItemList.querySelector('.no-items') || document.createElement('li');
            noItemsMessage.className = 'no-items';
            noItemsMessage.textContent = filter ? '没有匹配的文档。' : '没有找到已保存的文档。';
            items.forEach(item => {
                const name = item.dataset.name ? item.dataset.name.toLowerCase() : '';
                if (name.includes(filter)) { item.style.display = 'flex'; visibleCount++; }
                else { item.style.display = 'none'; }
            });
             if (visibleCount === 0 && items.length > 0) { if (!savedItemList.contains(noItemsMessage)) savedItemList.appendChild(noItemsMessage); noItemsMessage.style.display = 'block'; }
             else if (visibleCount > 0) { if (savedItemList.contains(noItemsMessage)) noItemsMessage.style.display = 'none'; }
             else if (items.length === 0) { if (!savedItemList.contains(noItemsMessage)) { savedItemList.innerHTML = ''; savedItemList.appendChild(noItemsMessage); } noItemsMessage.style.display = 'block'; }
        }
        function showHistoryModal() { populateHistoryModal(); }
        function hideHistoryModal() { historyModal.style.display = 'none'; }
        async function populateHistoryModal() { 
             try {
                const items = await loadAllHistory();
                historyItemList.innerHTML = '';
                const noItemsLi = '<li class="no-items">没有编辑历史记录。</li>';
                if (items && items.length > 0) {
                    items.forEach(item => {
                        const li = document.createElement('li');
                        li.className = 'history-item';
                        li.dataset.id = item.id;
                        const previewText = item.content.substring(0, 60).replace(/\n/g, ' ') + (item.content.length > 60 ? '...' : '');
                        li.innerHTML = `
                            <div class="item-info">
                                <span class="item-timestamp">记录于: ${formatTimestamp(item.timestamp)}</span>
                                <span class="item-content-preview" title="${escapeHtml(item.content.substring(0, 200))}">${escapeHtml(previewText)}</span>
                            </div>
                            <div class="item-actions">
                                <button class="small primary" onclick="handleRestoreHistory(${item.id})" title="恢复此版本到编辑器">恢复</button>
                                <button class="small danger" onclick="handleDeleteItem(event, ${item.id}, 'history')" title="删除此历史记录">删除</button>
                            </div>`;
                        historyItemList.appendChild(li);
                    });
                } else { historyItemList.innerHTML = noItemsLi; }
                 historyModal.style.display = 'flex';
				 historyModal.classList.add('show-flex');
            } catch (error) {
                showToast(`加载历史列表失败: ${error}`);
                historyItemList.innerHTML = '<li class="no-items" style="color:red;">加载历史列表时出错。</li>';
                historyModal.style.display = 'flex';
				historyModal.classList.add('show-flex');
            }
        }

        // --- Action Handlers ---
        async function handleSaveNew() { 
            const content = editor.value;
            if (!content.trim()) { showToast("编辑器内容为空，无法保存。"); return; }
            const defaultName = `Markdown ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`;
            const name = prompt("请输入新文档的名称:", defaultName);
            if (name === null || name.trim() === "") { showToast("已取消保存或名称无效。"); return; }
            try {
                const newId = await saveMarkdown(name.trim(), content); 
                showToast(`"${name.trim()}" 已成功保存！`);
                if (newId) setActiveSavedDocumentState(newId, name.trim(), content);
                else clearActiveSavedDocumentState(); 
                hideLoadModal();
            }
            catch (error) { console.error("Save new failed:", error); }
        }

        async function handleSaveAsVersion() {
            const content = editor.value;
            if (!content.trim()) { showToast("编辑器内容为空，无法保存。"); return; }
            if (!activeSavedDocument.id || !activeSavedDocument.name) {
                 showToast("没有可作为版本的原始文档。请先加载一个文档。"); return;
            }
            const versionedName = `${activeSavedDocument.name} v.${getTimestampForFilename(true)}`;
            const name = prompt("请输入新版本文档的名称:", versionedName);
            if (name === null || name.trim() === "") { showToast("已取消保存或名称无效。"); return; }

            try {
                const newId = await saveMarkdown(name.trim(), content);
                showToast(`版本 "${name.trim()}" 已成功另存！`);
                if (newId) setActiveSavedDocumentState(newId, name.trim(), content); 
                hideLoadModal();
            } catch (error) {
                console.error("Save as version failed:", error);
            }
        }


        async function handleUpdateItem(event, id) { 
            event.stopPropagation();
            const content = editor.value;
            if (!content.trim()) { showToast("编辑器内容为空，无法更新。"); return; }
            try {
                const itemToUpdate = await loadMarkdownById(id);
                if (!itemToUpdate) { showToast("找不到要更新的项目。"); populateModal(true); return; }
                if (confirm(`确定要用当前编辑器内容覆盖 "${itemToUpdate.name}" 吗？`)) {
                    const newName = prompt("请输入更新后的名称（留空则保留原名）:", itemToUpdate.name);
                     if (newName === null) { showToast("更新已取消。"); return; }
                    const finalName = (newName.trim() === "") ? itemToUpdate.name : newName.trim();
                    await updateMarkdown(id, finalName, content);
                    showToast(`"${finalName}" 已成功更新！`);
                    setActiveSavedDocumentState(id, finalName, content);
                    hideLoadModal();
                } else { showToast("更新已取消。"); }
            } catch (error) { console.error("Update failed:", error); }
        }
        async function handleLoadItem(id) { 
             try {
                 const item = await loadMarkdownById(id);
                 if (item) {
                     editor.value = item.content;
                     requestPreviewUpdate();
                     setActiveSavedDocumentState(item.id, item.name, item.content); // This will call checkAndManageDiffForLongText
                     hideLoadModal(); editor.scrollTop = 0;
					 showToast(`已加载: ${item.name}`);
                     triggerHistorySave(); 
                     // handleContentChangeForAssociation(); // Already called by setActiveSavedDocumentState via checkAndManageDiff
                     updateLoadSampleOrRevertButtonState();
					 updateWordCount();
                 } else { showToast("无法找到该项目。"); }
             } catch (error) { console.error("Load item failed:", error); }
        }
        async function handleRestoreHistory(id) { 
             try {
                 const item = await loadHistoryById(id);
                 if (item) {
                     editor.value = item.content;
                     requestPreviewUpdate();
                     hideHistoryModal(); editor.scrollTop = 0;
					 showToast(`已从 ${formatTimestamp(item.timestamp)} 恢复`);
                     lastSavedHistoryContent = item.content;
                     clearActiveSavedDocumentState(true); 
                     updateLoadSampleOrRevertButtonState();
					 updateWordCount();
                 } else { showToast("无法找到该历史记录。"); }
             } catch (error) { console.error("Restore history failed:", error); }
        }
        async function handleDeleteItem(event, id, type) { 
             event.stopPropagation();
             const listElement = (type === 'saved') ? savedItemList : historyItemList;
             const itemElement = listElement.querySelector(`li[data-id='${id}']`);
             const itemName = (type === 'saved' && itemElement) ? itemElement.dataset.name : `此${type === 'saved' ? '文档' : '历史记录'}`;
             const deleteFunction = (type === 'saved') ? deleteMarkdownById : deleteHistoryById;

             if (confirm(`确定要删除 "${itemName}" 吗？此操作无法撤销。`)) {
                 try {
                     const success = await deleteFunction(id);
                     if (success) {
                        if (itemElement) {
                            itemElement.style.transition = 'opacity 0.3s ease-out, height 0.3s ease-out, margin 0.3s ease-out, padding 0.3s ease-out, border 0.3s ease-out';
                            itemElement.style.opacity = '0'; itemElement.style.height = '0'; itemElement.style.margin = '0'; itemElement.style.padding = '0'; itemElement.style.border = 'none';
                            setTimeout(() => {
                                if (itemElement.parentNode) itemElement.remove();
                                if (type === 'saved') {
                                    filterSavedItems();
                                    if (activeSavedDocument.id === id) {
                                        clearActiveSavedDocumentState(true);
                                        updateLoadSampleOrRevertButtonState();
                                    }
                                }
                                else { if (historyItemList.querySelectorAll('.history-item').length === 0) { historyItemList.innerHTML = '<li class="no-items">没有编辑历史记录。</li>'; } }
                            }, 300);
                        }
                        showToast(`"${itemName}" 已删除。`);
                     } else { showToast(`删除 "${itemName}" 失败。`); }
                 } catch (error) { console.error(`Delete ${type} failed:`, error); }
             }
        }

        // Close modals on outside click or Escape key
        window.onclick = function(event) { 
            if (event.target == loadModal) hideLoadModal();
            if (event.target == historyModal) hideHistoryModal();
            if (event.target == diffConfigModal) hideDiffConfigModal();
        }
        window.addEventListener('keydown', function(event) { 
            if (event.key === 'Escape') {
                if (['block', 'flex'].includes(loadModal.style.display)) hideLoadModal();
                if (['block', 'flex'].includes(historyModal.style.display)) hideHistoryModal();
                if (['block', 'flex'].includes(diffConfigModal.style.display)) hideDiffConfigModal();
            }
        });


        // --- Utility Functions ---
        function escapeHtml(unsafe) { 
            if (typeof unsafe !== 'string') return '';
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
         }
         function formatTimestamp(date) { 
             if (!(date instanceof Date)) date = new Date(date);
             if (isNaN(date)) return "Invalid Date";
             try { return date.toLocaleString('zh-CN', { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' }); }
             catch (e) { console.error("Error formatting date:", e); return "Error Date"; }
        }
        function sanitizeFilenameComponent(name) { 
            if (!name || typeof name !== 'string') return '';
            return name.trim().toLowerCase().replace(/\s+/g, '-').replace(/[^\w.-]/g, '').substring(0, 50);
        }
        function getTimestampForFilename(short = false) { 
            const now = new Date();
            if (short) { 
                 return `${now.getFullYear().toString().slice(-2)}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}`;
            }
            return `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}-${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
        }
        function truncateText(text, maxLength) {
            if (typeof text !== 'string') return '';
            return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
        }
        
        function generateBaseFilename() { 
            let baseName = '';
            if (isDiffTrackingEnabled && currentDiffAnalysisResult.isRetained && activeSavedDocument.id && activeSavedDocument.name) {
                baseName = sanitizeFilenameComponent(activeSavedDocument.name);
            }

            if (!baseName) { 
                const content = editor.value.trim();
                const h1Match = content.match(/^#\s+(.*)/m);
                if (h1Match && h1Match[1]) {
                    baseName = sanitizeFilenameComponent(h1Match[1]);
                } else {
                    const firstLine = content.split('\n')[0];
                    if (firstLine) {
                        baseName = sanitizeFilenameComponent(firstLine.substring(0,50)); 
                    }
                }
            }
            if (!baseName || baseName.length === 0) baseName = 'markdown-export';
            return `${baseName}-${getTimestampForFilename()}`;
        }


        // --- Scroll Sync ---
		function syncScroll(source, target) { 
			if (isSyncing) return; isSyncing = true;
			const ratio = source.scrollTop / (source.scrollHeight - source.clientHeight || 1);
			target.scrollTop = ratio * (target.scrollHeight - target.clientHeight);
			requestAnimationFrame(() => { isSyncing = false; });
		}
		editor.addEventListener('scroll', () => syncScroll(editor, preview));
		preview.addEventListener('scroll', () => syncScroll(preview, editor));

        // --- Initialization ---
        editor.addEventListener('input', () => {
            requestPreviewUpdate();
            scheduleHistorySave();
            checkAndManageDiffForLongText();
            handleContentChangeForAssociation(); 
            updateLoadSampleOrRevertButtonState();
			updateWordCount();
        });
        editor.addEventListener('paste', (event) => {
            const pastedText = (event.clipboardData || window.clipboardData).getData('text');
            if (pastedText.length > LONG_TEXT_THRESHOLD / 2) { 
                 // Check if auto-disable is off and diff is on, then show a pre-computation toast
                if (isDiffTrackingEnabled && !autoDisableDiffForLongTextToggle.checked && pastedText.length > LONG_TEXT_THRESHOLD) {
                    showToast("正在处理大量粘贴内容，智能识别分析可能需要一些时间...", 3000);
                } else if (pastedText.length > LONG_TEXT_THRESHOLD) {
                    showToast("正在处理大量粘贴内容...", 2000);
                }
            }
            setTimeout(() => { 
                requestPreviewUpdate();
                triggerHistorySave();
                checkAndManageDiffForLongText();
                handleContentChangeForAssociation(); 
                updateLoadSampleOrRevertButtonState();
				updateWordCount();
            }, 0);
        });
        editor.addEventListener('blur', () => {
             clearTimeout(historySaveTimeout);
             saveCurrentStateToHistory(); 
        });

        // Initialize elements that might not be immediately available if script is in <head>
        // But since it's at the end of body, this is fine.
        
        handleLoadSampleOrRevert(); // Load initial sample
        updateLoadSampleOrRevertButtonState(); // Set initial button state

        initDB().then(() => {
            console.log("DB Initialized.");
            pruneHistory();
            
            if (typeof Diff === 'undefined') { 
                console.error("jsdiff library (Diff) not loaded!");
                showToast("错误：智能识别组件未加载，关联功能将不可用。", 5000);
                isDiffTrackingEnabled = false; 
                jsdiffInstance = null; 
            } else {
                jsdiffInstance = Diff; 
                console.log("jsdiff (Diff) instance ready.");
            }
            loadDiffSettings(); 
            const diffConfigButton = document.querySelector('button[onclick="showDiffConfigModal()"]');
            if (diffConfigButton && !jsdiffInstance) diffConfigButton.disabled = true;
            
            checkAndManageDiffForLongText(); // Initial check on page load

        }).catch(err => console.error("Initial DB connection failed:", err));

    </script>
</body>
</html>