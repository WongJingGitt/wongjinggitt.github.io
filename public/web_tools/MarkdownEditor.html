<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Markdown转换工具</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- PDF/Image Export Libs -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- DOCX Export Lib -->
    <script src="https://unpkg.com/html-docx-js/dist/html-docx.js"></script>
    <!-- Highlight JS -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.css" integrity="sha512-jYtlOKxyOGJQxuHAR9h4PK04vh9HzaxI0dHVXx/kqICgw82nv3UpzWkaef+Fg8g4XJEvf/W+sPOnaeYQp5SRaQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Diff Lib (jsdiff) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/7.0.0/diff.min.js"></script>
    <style>
         :root {
            --bg-color: #f8f9fa;
            --preview-bg: #ffffff;
            --border-color: #e1e4e8;
            --text-color: #24292e;
            --secondary-text-color: #6a737d;
            --primary-color: #0366d6;
            --primary-hover-color: #0056b3;
            --danger-color: #d73a49;
            --danger-hover-color: #cb2431;
            --modal-overlay-bg: rgba(0,0,0,0.6);
            --modal-content-bg: #ffffff;
            --diff-enabled-color: #28a745; /* Bootstrap Success Green */
            --diff-disabled-color: #6c757d; /* Bootstrap Secondary Grey */
        }

        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .container {
            padding: 2rem;
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 2rem;
            margin: 0 auto;
            height: calc(100vh - 1rem);
            box-sizing: border-box;
        }

        .editor-box, .preview-box {
            background: var(--preview-bg);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow: hidden;
            min-width: 0;
        }

        .markdown-body {
            background: var(--preview-bg) !important;
            padding: 1.5rem !important;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            overflow: auto;
        }

        .title-toolbar {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .preview-title-extra { 
            margin-left: auto; 
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        #diffStatusIndicator {
            font-size: 0.8em; 
            font-weight: 500;
            padding: 0.2em 0.6em; 
            border-radius: 4px;
            color: white;
            line-height: 1.5; 
            white-space: nowrap;
        }
        #diffStatusIndicator.enabled {
            background-color: var(--diff-enabled-color);
        }
        #diffStatusIndicator.disabled {
            background-color: var(--diff-disabled-color);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px; 
            height: 20px; 
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 20px; 
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px; 
            width: 14px;  
            left: 3px;    
            bottom: 3px;  
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px); 
        }


        select, button, input[type="search"], input[type="number"], input[type="range"] {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: white;
            font-size: 0.9em;
            box-sizing: border-box;
        }
        input[type="range"] {
            padding: 0; 
        }
        button {
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        button:hover {
             border-color: #c6cbd1;
             background-color: #f6f8fa;
        }
        button:active {
             background-color: #f3f4f6;
             border-color: #c6cbd1;
             box-shadow: inset 0 1px 0 rgba(225,228,232,0.2);
        }


        button.primary {
            background: var(--primary-color);
            color: white;
            border: 1px solid var(--primary-color);
        }

        button.primary:hover {
            background: var(--primary-hover-color);
            border-color: var(--primary-hover-color);
        }

        button.danger {
            background-color: var(--danger-color);
            color: white;
            border-color: var(--danger-color);
         }
         button.danger:hover {
            background-color: var(--danger-hover-color);
            border-color: var(--danger-hover-color);
         }
         button.small {
            padding: 0.3rem 0.8rem;
            font-size: 0.8em;
         }

         .notice {
            color: var(--secondary-text-color);
            font-size: 0.9em;
            margin-top: 0;
        }
        .card-title {
            padding: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            flex-shrink: 0;
            box-sizing: border-box;
            flex-wrap: wrap;
            gap: 10px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
        }
        .card-body {
            flex-grow: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .text-title {
            font-size: 1.25em;
            font-weight: 600;
            margin-right: 1rem; 
            white-space: nowrap;
            display: flex; 
            align-items: center; 
        }
        #activeDocIndicatorText { 
            font-weight: normal;
            font-size: 0.8em;
            color: var(--secondary-text-color);
            margin-left: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px; 
        }
        .title-button-group {
             display: flex;
             gap: 0.5rem;
             align-items: center;
			 width: 100%;
			 justify-content: flex-end;
        }
		.title-button-item {
			height: 35px;
			min-width: 75px;
			display: inline-flex;
			align-items: center;
			justify-content: center;
            gap: 0.4em;
            padding: 0.5rem 0.8rem;
            white-space: nowrap;
		}
        .icon-button svg {
            vertical-align: middle;
            flex-shrink: 0;
        }
        .editor {
            width: 100%;
            font-family: 'Fira Code', 'Consolas', monospace;
            border-radius: 6px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            border: 1px solid var(--border-color);
            background: #fafafa;
        }

        #editor {
            width: 100%;
            flex-grow: 1;
            padding: 15px;
            font-size: 14px;
            line-height: 1.6;
            border: none;
            background: transparent;
            resize: none;
            tab-size: 4;
            overflow-y: auto;
            box-sizing: border-box;
        }

        #editor:focus {
            outline: none;
        }

        .toolbar {
            padding: 8px 15px;
            background: #f6f8fa;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.85em;
            color: var(--secondary-text-color);
            flex-shrink: 0;
            box-sizing: border-box;
            width: 100%;
            user-select: none;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: var(--modal-overlay-bg);
            backdrop-filter: blur(3px);
        }

        .modal-content {
            background-color: var(--modal-content-bg);
            margin: 8% auto;
            padding: 25px;
            border: 1px solid var(--border-color);
            width: 85%;
            max-width: 650px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            position: relative;
            animation: fadeIn 0.3s ease-out;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.8rem;
        }

        .modal-close-btn {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            line-height: 1;
            background: none;
            border: none;
            padding: 0 5px;
            cursor: pointer;
        }

        .modal-close-btn:hover,
        .modal-close-btn:focus {
            color: black;
            text-decoration: none;
        }

        .modal h2 {
            margin: 0;
            font-weight: 600;
            font-size: 1.3em;
        }
        .modal-toolbar {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        #searchInput, #historySearchInput {
            flex-grow: 1;
            min-width: 200px;
        }
        #saveNewButton {
             display: none;
        }

        .saved-item-list, .history-item-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 50vh;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }

        .saved-item, .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
            transition: background-color 0.15s ease-in-out, border-left 0.15s ease-in-out; 
            gap: 10px;
        }
        .saved-item:last-child, .history-item:last-child {
            border-bottom: none;
        }
        .saved-item:hover, .history-item:hover {
            background-color: #f6f8fa;
        }
        .saved-item.highlighted-active-doc {
            background-color: #e6f7ff; 
            border-left: 4px solid var(--primary-color);
            font-weight: 500;
        }
        .saved-item.highlighted-active-doc .item-name {
            color: var(--primary-hover-color);
        }


        .item-info {
            display: flex;
            flex-direction: column;
            gap: 3px;
            flex-grow: 1;
            min-width: 0;
        }

        .item-name {
            font-weight: 500;
            color: var(--text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .item-content-preview {
            font-size: 0.9em;
            color: var(--secondary-text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 350px;
            display: inline-block;
        }

        .item-timestamp {
            font-size: 0.8em;
            color: var(--secondary-text-color);
        }
        .item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .no-items {
             text-align: center;
             color: var(--secondary-text-color);
             padding: 2rem 0;
             font-style: italic;
             border-bottom: none !important;
             display: block !important;
        }
        .no-items:hover {
             background-color: transparent !important;
        }
        .toast-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.75);
            color: #fff;
            border-radius: 6px;
            z-index: 1050;
            font-family: sans-serif;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            text-align: center;
            pointer-events: none;
        }
        .toast-message.show {
            opacity: 1;
        }
        /* Styles for Diff Config Modal */
        .config-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .config-item label {
            font-weight: 500;
            font-size: 0.95em;
        }
        .config-item .input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .config-item input[type="number"] {
            width: 80px; 
        }
        .config-item input[type="range"] {
            flex-grow: 1;
        }
        .config-note {
            font-size: 0.8em;
            color: var(--secondary-text-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 编辑区 -->
        <div class="editor-box">
            <div class="card-title">
                <div class="text-title">
                    Markdown 编辑器
                    <span id="activeDocIndicatorText"></span>
                </div>
                <div class="title-button-group">
                    <button onclick="importMarkdownFile()" title="Import Markdown file" class="title-button-item icon-button">
						<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-upload"><path d="M2.75 14A1.75 1.75 0 0 1 1 12.25v-2.5a.75.75 0 0 1 1.5 0v2.5c0 .138.112.25.25.25h10.5a.25.25 0 0 0 .25-.25v-2.5a.75.75 0 0 1 1.5 0v2.5A1.75 1.75 0 0 1 13.25 14Z M8 1.75a.75.75 0 0 1 .75.75v6.51L11.03 6.78a.75.75 0 0 1 1.06 1.06l-3.5 3.5a.75.75 0 0 1-1.06 0l-3.5-3.5a.75.75 0 1 1 1.06-1.06l2.22 2.22V2.5a.75.75 0 0 1 .75-.75Z"></path></svg>
						导入
					</button>
                    <button onclick="showLoadModal()" title="Load saved markdown" class="title-button-item icon-button">
						<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-download"><path d="M2.75 14A1.75 1.75 0 0 1 1 12.25v-2.5a.75.75 0 0 1 1.5 0v2.5c0 .138.112.25.25.25h10.5a.25.25 0 0 0 .25-.25v-2.5a.75.75 0 0 1 1.5 0v2.5A1.75 1.75 0 0 1 13.25 14Z M8 11.75a.75.75 0 0 1-.75-.75V1.5a.75.75 0 0 1 1.5 0v9.5a.75.75 0 0 1-.75.75Zm-4.28-4.28a.75.75 0 0 1 0-1.06l4.25-4.25a.75.75 0 0 1 1.06 0l4.25 4.25a.75.75 0 0 1-1.06 1.06L8.75 4.31V9.5a.75.75 0 0 1-1.5 0V4.31L3.78 7.47a.75.75 0 0 1-1.06 0Z"></path></svg>
						加载
					</button>
                    <button class="primary title-button-item icon-button" onclick="showSaveModal()" title="Save or update markdown">
						<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-file-directory-fill"><path d="M1.75 1A1.75 1.75 0 0 0 0 2.75v10.5C0 14.216.784 15 1.75 15h12.5A1.75 1.75 0 0 0 16 13.25v-8.5A1.75 1.75 0 0 0 14.25 3H7.5a.25.25 0 0 1-.2-.09L5.95 1.36A.75.75 0 0 0 5.41 1H1.75Z"></path></svg>
						保存
					</button>
                    <button onclick="showHistoryModal()" title="View edit history" class="title-button-item icon-button">
						<svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-history"><path d="M1.643 3.143L.427 1.927A.25.25 0 0 0 0 2.104V5.75c0 .138.112.25.25.25h3.646a.25.25 0 0 0 .177-.427L2.715 4.215a6.5 6.5 0 1 1-1.18 4.458.75.75 0 1 0-1.493.154 8.001 8.001 0 1 0 1.6-5.684zM7.75 4a.75.75 0 0 1 .75.75v4.336l3.47 2.023a.75.75 0 0 1-.74 1.298l-3.75-2.165A.75.75 0 0 1 7 9.75V4.75a.75.75 0 0 1 .75-.75z"></path></svg>
						历史
					</button>
                    <button onclick="showDiffConfigModal()" title="Configure Diff Tracking" class="title-button-item icon-button">
                        <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-gear"><path fill-rule="evenodd" d="M8 11.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Zm0 1.5a5 5 0 1 0 0-10 5 5 0 0 0 0 10ZM5.44 8A2.56 2.56 0 0 1 8 5.44v.035a.75.75 0 0 1 0 1.5v-.035A.97.97 0 0 0 8 6.91a.97.97 0 0 0-.97.97.97.97 0 0 0 .97.97.97.97 0 0 0 .97-.97V8a2.56 2.56 0 0 1-2.56 2.56H5.47a.75.75 0 0 1 0-1.5h.005A2.524 2.524 0 0 1 5.44 8Zm4.12-2.56A2.56 2.56 0 0 1 10.53 8h.005a.75.75 0 0 1 0 1.5H10.5A2.56 2.56 0 0 1 8 10.56v-.035a.75.75 0 0 1 0-1.5v.035A.97.97 0 0 0 8 9.09a.97.97 0 0 0 .97-.97A.97.97 0 0 0 8 7.15.97.97 0 0 0 7.03 8.12V8A2.56 2.56 0 0 1 9.56 5.44Zm2.06.7a.75.75 0 0 1 1.06-.02l.003.004 1.5 1.5.003.003a.75.75 0 0 1 .02 1.06l-.003.004-1.5 1.5-.004.003a.75.75 0 0 1-1.06.02l.004-.003-1.5-1.5-.004-.003a.75.75 0 0 1-.02-1.06l.003-.004 1.5-1.5Zm-8.24 4.12a.75.75 0 0 1 1.06.02l-.003-.004 1.5 1.5-.003-.003a.75.75 0 0 1 .02 1.06l.003.004-1.5 1.5.004.003a.75.75 0 0 1-1.06.02l-.004-.003-1.5-1.5.004-.003a.75.75 0 0 1-.02-1.06l-.003.004 1.5-1.5Z"></path></svg>
                        Diff配置
                    </button>
                    <button class="title-button-item" onclick="loadSample()" >加载示例</button>
                </div>
            </div>
            <div class="card-body">
                <div class="editor">
                    <div class="toolbar">Markdown Editor (Tab/Shift+Tab supported)</div>
                    <textarea id="editor" placeholder="Start typing markdown here..."></textarea>
                </div>
            </div>
        </div>

        <!-- 预览区 -->
        <div class="preview-box">
            <div  class="card-title">
                <div class="text-title">
                    实时预览
                </div>
                 <div class="preview-title-extra"> 
                    <span id="diffStatusIndicator">追踪关闭</span>
                    <label class="toggle-switch" title="切换Diff内容追踪功能">
                        <input type="checkbox" id="diffTrackingToggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="title-toolbar">
                    <select id="format">
                        <option value="image" selected>图片</option>
                        <option value="html">HTML</option>
                        <option value="pdf">PDF</option>
                        <option value="docx">DOCX</option>
                        <option value="markdown">Markdown (.md)</option>
                    </select>
                    <button class="primary" onclick="exportFile(event)">导出文件</button>
                    <p class="notice">提示：生成图片/PDF可能需5-10秒</p>
                </div>
            </div>
            <div class="card-body">
                <div class="markdown-body" id="preview"></div>
            </div>
        </div>
    </div>

     <!-- Load/Save Markdown Modal -->
    <div id="loadModal" class="modal">
        <div class="modal-content">
             <div class="modal-header">
                 <h2 id="modalTitle">加载已保存的 Markdown</h2>
                 <button class="modal-close-btn" onclick="hideLoadModal()" title="关闭">&times;</button>
             </div>
             <div class="modal-toolbar">
                <input type="search" id="searchInput" placeholder="按名称搜索..." oninput="filterSavedItems()">
                <button id="saveNewButton" class="primary" onclick="handleSaveNew()">另存为新...</button>
             </div>
            <ul id="savedItemList" class="saved-item-list">
                 <li class="no-items">没有找到已保存的文档。</li>
            </ul>
        </div>
    </div>

    <!-- Edit History Modal -->
    <div id="historyModal" class="modal">
        <div class="modal-content">
             <div class="modal-header">
                 <h2 id="historyModalTitle">编辑历史记录</h2>
                 <button class="modal-close-btn" onclick="hideHistoryModal()" title="关闭">&times;</button>
             </div>
            <ul id="historyItemList" class="history-item-list">
                 <li class="no-items">没有编辑历史记录。</li>
            </ul>
        </div>
    </div>

    <!-- Diff Config Modal -->
    <div id="diffConfigModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Diff追踪配置</h2>
                <button class="modal-close-btn" onclick="hideDiffConfigModal()" title="关闭">&times;</button>
            </div>
            <div class="config-item">
                <label for="diffDebounceTimeInput">防抖触发时间 (毫秒)</label>
                <div class="input-group">
                    <input type="number" id="diffDebounceTimeInput" min="1000" step="100">
                </div>
                <p class="config-note">编辑器内容停止变化后，等待此时间再进行Diff计算。最小值1000毫秒。</p>
            </div>
            <div class="config-item">
                <label for="diffMatchThresholdInput">匹配容忍度 (%)</label>
                <div class="input-group">
                    <input type="range" id="diffMatchThresholdRange" min="50" max="100" step="1">
                    <input type="number" id="diffMatchThresholdInput" min="50" max="100" step="1" style="width: 70px;"> %
                </div>
                <p class="config-note">原始文档内容在此百分比以上仍然存在于当前编辑内容中时，判定为追踪。范围50% - 100%。</p>
            </div>
            <button class="primary" onclick="handleSaveDiffSettings()">保存配置</button>
        </div>
    </div>


    <!-- 独立示例内容 -->
    <script id="sampleMarkdown" type="text/template">
# 现代化文档转换工具 (v2.2)

## 功能特性

- [x] ​**​实时HTML预览​**​
- [x] 多格式导出支持 (HTML, 图片, **PDF**, **DOCX**, **Markdown**)
- [x] 专业样式渲染 (GitHub Markdown CSS + Highlight.js)
- [x] 内容本地存储 (IndexedDB) - 支持搜索、更新、删除
- [x] ​**​编辑历史记录​**​ (自动保存，上限50条)
- [x] ​**​Markdown文件导入​**
- [x] ​**​可配置的Diff内容追踪，持续追踪当前选中的方案。​**
- [ ] <span style="color: #A0A1A7;">更多功能敬请期待...</span>

```javascript
// 完整的代码示例 (JS)
function greet(name) {
    // Uses template literals
    return `Hello, ${name}! Welcome to the editor.`;
}
console.log(greet('Developer'));
// Expected Output: Hello, Developer! Welcome to the editor.

/* Multi-line comment test
   Still works! */
```

```python
# Python Code Block Example
import sys

def check_version():
  """Prints the Python version."""
  print(f"Python Version: {sys.version}")

if __name__ == "__main__":
  check_version()
```

## 使用指南

1.  在左侧 **编辑器** 中输入或粘贴Markdown文本，或点击 **导入** 按钮加载本地 `.md` / `.txt` 文件。
2.  右侧将 **实时预览** 渲染后的效果。
3.  可配置 **Diff追踪** 功能（预览区右上角开关及编辑器上方“Diff配置”按钮）：
    *   开启后，当编辑器内容与当前加载的已保存文档（活动文档）的原始内容保留度高于设定阈值（即使增加了许多新内容），系统仍会认为您在编辑该活动文档的扩展版本。
    *   **导出文件名**：若判定为追踪活动文档，将使用该文档名。
    *   **保存弹窗**：若判定为追踪活动文档，将在保存列表中高亮并滚动到该文档。
4.  点击编辑器上方的 **保存** 按钮:
    *   在弹出窗口中点击 **另存为新...** 以创建新条目。
    *   点击列表中某一项旁的 **更新** 按钮以覆盖现有条目。
5.  点击编辑器上方的 **加载** 按钮:
    *   使用 **搜索框** 快速查找。
    *   点击列表中某一项旁的 **加载** 按钮将其内容填入编辑器（这将成为新的活动文档）。
    *   点击 **删除** 按钮移除条目。
6.  点击编辑器上方的 **历史** 按钮:
    *   查看自动保存的编辑记录 (最近优先)。
    *   点击 **恢复** 将该版本内容加载到编辑器（这会清除活动文档状态）。
    *   点击 **删除** 移除该条历史记录。
7.  在预览区上方选择 **导出格式** (HTML, 图片, PDF, DOCX, Markdown)，然后点击 **导出文件** 下载。 *PDF导出将保留视觉样式，但文本不可选。DOCX会尝试转换结构和基本样式。Markdown将导出纯文本。*

> 专业的技术文档与演示解决方案，提供更完善的本地管理和追溯功能！

---

## 宽内容测试

### 表格

| Header 1 | Header 2 | Header 3 | Header 4 | Header 5 | Header 6 | Header 7 | Header 8 | Header 9 | Header 10 | Header 11 | Header 12 |
|---|---|---|---|---|---|---|---|---|---|---|---|
| Data 1 | Data 2 | Data 3 | Data 4 | Data 5 | Data 6 | Data 7 | Data 8 | Data 9 | Data 10 | Data 11 | Data 12 |
| Long Data Entry Cell Number One | Long Data Entry Cell Number Two | Long Data Entry Cell Number Three | Long Data Entry Cell Number Four | Long Data Entry Cell Number Five | Long Data Entry Cell Number Six | Long Data Entry Cell Number Seven | Long Data Entry Cell Number Eight | Long Data Entry Cell Number Nine | Long Data Entry Cell Number Ten | Long Data Entry Cell Number Eleven | Long Data Entry Cell Number Twelve |

### 长代码块

```text
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
```
    </script>

    <script>
        // --- Global Variables & Constants ---
        const editor = document.getElementById('editor');
        const preview = document.getElementById('preview');
        const sampleContent = document.getElementById('sampleMarkdown').textContent.trim();
        const loadModal = document.getElementById('loadModal');
        const savedItemList = document.getElementById('savedItemList');
        const searchInput = document.getElementById('searchInput');
        const modalTitle = document.getElementById('modalTitle');
        const saveNewButton = document.getElementById('saveNewButton');
        const historyModal = document.getElementById('historyModal');
        const historyItemList = document.getElementById('historyItemList');
        const activeDocIndicatorEl = document.getElementById('activeDocIndicatorText'); 

        const DB_NAME = 'markdownDB';
        const SAVED_STORE_NAME = 'savedMarkdown';
        const HISTORY_STORE_NAME = 'editHistory';
        const HISTORY_LIMIT = 50;
        let db;
        let historySaveTimeout;
        let lastSavedHistoryContent = null;
        let isSyncing = false;

        // --- Diff Tracking Variables ---
        let isDiffTrackingEnabled = false;
        let diffDebounceTime = 1500; 
        let diffMatchThreshold = 0.85; 
        let jsdiffInstance = null; 
        let diffDebounceTimeout = null;
        let isContentConsideredSameAsActiveDoc = false; 

        let activeSavedDocument = { 
            id: null,
            name: null,
            originalContent: null
        };

        const diffConfigModal = document.getElementById('diffConfigModal');
        const diffDebounceTimeInput = document.getElementById('diffDebounceTimeInput');
        const diffMatchThresholdRange = document.getElementById('diffMatchThresholdRange');
        const diffMatchThresholdInput = document.getElementById('diffMatchThresholdInput');
        const diffTrackingToggle = document.getElementById('diffTrackingToggle');
        const diffStatusIndicator = document.getElementById('diffStatusIndicator');


        // --- Toast Notification ---
		function showToast(message, duration = 3000) {
		    document.querySelectorAll('.toast-message').forEach(t => t.remove());
            const toast = document.createElement('div');
            toast.textContent = message;
		    toast.className = 'toast-message';
		    document.body.appendChild(toast);
		    requestAnimationFrame(() => {
                requestAnimationFrame(() => { toast.classList.add('show'); });
            });
		    setTimeout(() => {
		        toast.classList.remove('show');
		        toast.addEventListener('transitionend', () => toast.remove());
		    }, duration);
		}

        // --- Editor & Indentation Logic ---
        editor.addEventListener('keydown', (e) => {
            if (e.key === 'Tab' && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
                e.preventDefault(); handleIndentation('indent');
            } else if (e.key === 'Tab' && e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey) {
                e.preventDefault(); handleIndentation('unindent');
            }
        });
        function handleIndentation(action) {
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const value = editor.value;
            const tab = '    ';
            if (start === end) {
                const lineStart = value.lastIndexOf('\n', start - 1) + 1;
                if (action === 'indent') {
                    editor.setRangeText(tab, start, start, 'end');
                } else {
                    const line = value.substring(lineStart, start);
                    if (line.startsWith(tab)) { editor.setRangeText('', lineStart, lineStart + tab.length, 'end'); }
                    else if (line.startsWith('\t')) { editor.setRangeText('', lineStart, lineStart + 1, 'end'); }
                    else {
                         const leadingSpaces = line.match(/^[ ]{1,4}/);
                         if (leadingSpaces) { editor.setRangeText('', lineStart, lineStart + leadingSpaces[0].length, 'end'); }
                    }
                }
            } else {
                const selectionLineStart = value.lastIndexOf('\n', start - 1) + 1;
                const textToModify = value.substring(selectionLineStart, end);
                let modifiedText = '';
                let lineShiftFirst = 0;
                const lines = textToModify.split('\n');
                lines.forEach((line, index) => {
                    let currentLineShift = 0;
                    if (action === 'indent') {
                        modifiedText += tab + line; currentLineShift = tab.length;
                    } else {
                        if (line.startsWith(tab)) { modifiedText += line.substring(tab.length); currentLineShift = -tab.length; }
                        else if (line.startsWith('\t')) { modifiedText += line.substring(1); currentLineShift = -1; }
                        else {
                             const leadingSpaces = line.match(/^[ ]{1,4}/);
                             if (leadingSpaces) { modifiedText += line.substring(leadingSpaces[0].length); currentLineShift = -leadingSpaces[0].length; }
                             else { modifiedText += line; }
                        }
                    }
                    if (index < lines.length - 1) { modifiedText += '\n'; }
                    if (index === 0) {
                         if (start > selectionLineStart) { lineShiftFirst = currentLineShift > 0 ? tab.length : Math.max(currentLineShift, -(start - selectionLineStart)); }
                         else { lineShiftFirst = currentLineShift; }
                    }
                });
                editor.setRangeText(modifiedText, selectionLineStart, end, 'select');
                const finalStart = Math.max(selectionLineStart, start + lineShiftFirst);
                const lengthDifference = modifiedText.length - textToModify.length;
                const finalEnd = end + lengthDifference;
                editor.setSelectionRange(finalStart, finalEnd);
            }
            updatePreview(); 
            triggerHistorySave(); 
            handleContentChangeForDiff(); 
        }


        // --- Core Editor and Preview Logic ---
        marked.setOptions({
            highlight: (code, lang) => {
                const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                try {
                     if (language) { return hljs.highlight(code, { language, ignoreIllegals: true }).value; }
                } catch (e) { console.error(`Highlighting error for lang ${lang}:`, e); }
                try { return hljs.highlightAuto(code).value; }
                catch (autoError) {
                    console.error("Auto highlighting failed:", autoError);
                    const escapedCode = code.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    return `<pre><code class="hljs">${escapedCode}</code></pre>`;
                }
            },
            breaks: true, gfm: true
        });
        function loadSample() { 
            editor.value = sampleContent;
            updatePreview();
            showToast("示例内容已加载");
            lastSavedHistoryContent = null;
            clearActiveSavedDocumentState(true); 
        }
        function updatePreview() { 
            try {
                 preview.innerHTML = marked.parse(editor.value);
                 hljs.highlightAll();
            } catch (e) {
                 console.error("Markdown Parsing Error:", e);
                 preview.innerHTML = `<p style="color: red;">Error parsing Markdown. Check console for details.</p>`;
            }
        }


        // --- File Import Logic ---
        function importMarkdownFile() { 
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.md,.txt,text/markdown,text/plain';
            fileInput.onchange = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        editor.value = e.target.result;
                        updatePreview();
                        triggerHistorySave();
                        showToast(`文件 "${file.name}" 已导入！`);
                        clearActiveSavedDocumentState(true); 
                    };
                    reader.onerror = (e) => { console.error("File reading error:", e); showToast("文件读取失败。"); };
                    reader.readAsText(file);
                }
            };
            fileInput.click();
        }

        // --- Export Logic ---
        async function exportFile(event) {
            const format = document.getElementById('format').value;
            const markdownInput = editor.value;
            const exportButton = event.target;
            const originalButtonText = exportButton.textContent;

            exportButton.disabled = true;
            exportButton.textContent = '导出中...';

            const baseFilename = generateBaseFilename(); 
            let filenameWithExt = `${baseFilename}.txt`; 

            if (format === 'markdown') {
                try {
                    filenameWithExt = `${baseFilename}.md`;
                    triggerDownload(
                        URL.createObjectURL(new Blob([markdownInput], { type: 'text/markdown;charset=UTF-8' })),
                        filenameWithExt
                    );
                    showToast('Markdown 文件导出成功！');
                } catch (error) {
                    showToast(`导出失败: ${error.message}`);
                    console.error("Export Error (Markdown):", error);
                } finally {
                    exportButton.disabled = false;
                    exportButton.textContent = originalButtonText;
                }
                return;
            }

            const previewElement = document.getElementById('preview');
            try {
                previewElement.innerHTML = marked.parse(markdownInput);
                hljs.highlightAll();
            } catch (e) {
                showToast(`Markdown 解析错误，无法导出: ${e.message}`);
                exportButton.disabled = false;
                exportButton.textContent = originalButtonText;
                return;
            }

            const captureContainer = document.createElement('div');
            captureContainer.className = 'markdown-body';
            Object.assign(captureContainer.style, {
                position: 'absolute', left: '-9999px', top: '0px',
                padding: '2rem', background: 'var(--preview-bg)',
                width: previewElement.scrollWidth + 'px',
                minWidth: '600px', height: 'auto', overflow: 'visible',
                boxSizing: 'content-box'
            });
            const clonedPreview = previewElement.cloneNode(true);
            captureContainer.appendChild(clonedPreview);
            document.body.appendChild(captureContainer);

            await new Promise(resolve => requestAnimationFrame(resolve));
            await new Promise(resolve => setTimeout(resolve, 150));

            try {
                switch(format) {
                    case 'image':
                    case 'pdf':
                        const scale = window.devicePixelRatio || 2;
                        const canvas = await html2canvas(captureContainer, {
                            scale: scale, useCORS: true, logging: false, scrollX: 0, scrollY: 0,
                            windowWidth: captureContainer.scrollWidth,
                            windowHeight: captureContainer.scrollHeight,
                            backgroundColor: getComputedStyle(captureContainer).backgroundColor
                        });
                        if (format === 'image') {
                            filenameWithExt = `${baseFilename}.png`;
                            triggerDownload(canvas.toDataURL('image/png'), filenameWithExt);
                            showToast('图片导出成功！');
                        } else {
                            filenameWithExt = `${baseFilename}.pdf`;
                            const { jsPDF } = window.jspdf;
                            const imgData = canvas.toDataURL('image/png');
                            const imgProps = { width: canvas.width / scale, height: canvas.height / scale };
                            const pdf = new jsPDF({
                                orientation: imgProps.width > imgProps.height ? 'l' : 'p',
                                unit: 'px',
                                format: [imgProps.width, imgProps.height]
                            });
                            const pdfWidth = pdf.internal.pageSize.getWidth();
                            const pdfHeight = pdf.internal.pageSize.getHeight();
                            const ratio = Math.min(pdfWidth / imgProps.width, pdfHeight / imgProps.height);
                            pdf.addImage(imgData, 'PNG', (pdfWidth - imgProps.width * ratio) / 2, 0, imgProps.width * ratio, imgProps.height * ratio);
                            pdf.save(filenameWithExt);
                            showToast('PDF导出成功！(作为单页图片)');
                        }
                        break;
                    case 'html':
                        filenameWithExt = `${baseFilename}.html`;
                        const fullHTML = createFullHtml(clonedPreview.innerHTML);
                        triggerDownload(
                            URL.createObjectURL(new Blob([fullHTML], { type: 'text/html;charset=UTF-8' })),
                            filenameWithExt
                        );
                        showToast('HTML导出成功！');
                        break;
                    case 'docx':
                        filenameWithExt = `${baseFilename}.docx`;
                        const docxHtmlString = createFullHtml(clonedPreview.innerHTML);
                        if (typeof htmlDocx === 'undefined') throw new Error("html-docx-js library not loaded.");
                        const fileBlob = htmlDocx.asBlob(docxHtmlString);
                        triggerDownload(URL.createObjectURL(fileBlob), filenameWithExt);
                        showToast('DOCX导出成功！');
                        break;
                }
            } catch (error) {
                showToast(`导出失败: ${error.message}`);
                console.error("Export Error:", error);
            } finally {
                if (document.body.contains(captureContainer)) document.body.removeChild(captureContainer);
                exportButton.disabled = false;
                exportButton.textContent = originalButtonText;
            }
        }

        function createFullHtml(bodyContent) { 
            return `
                <!DOCTYPE html>
                <html lang="zh-CN" xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
                <head>
                    <meta charset="UTF-8">
                    <title>Exported Markdown</title>
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown.min.css">
                    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.css">
                    <style>
                        body { font-family: Calibri, sans-serif; font-size: 11pt; padding: 1in; margin: 0; }
                        .markdown-body { }
                        pre { background-color: #f6f8fa; border: 1px solid #e1e4e8; padding: 1em; overflow: auto; font-family: Consolas, monospace; }
                        code { font-family: Consolas, monospace; font-size: 90%; }
                        table { border-collapse: collapse; width: 100%; }
                        th, td { border: 1px solid #dfe2e5; padding: 6px 13px; }
                        blockquote { border-left: .25em solid #dfe2e5; color: #6a737d; padding: 0 1em; margin-left: 0; }
                        :root { --preview-bg: #ffffff; --border-color: #e1e4e8; }
                    </style>
                     <!--[if gte mso 9]>
                     <xml>
                         <w:WordDocument>
                         <w:View>Print</w:View>
                         <w:Zoom>100</w:Zoom>
                         <w:DoNotOptimizeForBrowser/>
                         </w:WordDocument>
                     </xml>
                     <![endif]-->
                </head>
                <body>
                    <div class="markdown-body">
                        ${bodyContent}
                    </div>
                 </body>
                </html>
            `;
        }
        function triggerDownload(dataURL, filename) { 
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            if (dataURL.startsWith('blob:')) {
                setTimeout(() => URL.revokeObjectURL(dataURL), 100);
            }
        }

        // --- IndexedDB Logic ---
        function initDB() { 
            return new Promise((resolve, reject) => {
                if (db) return resolve(db);
                const request = indexedDB.open(DB_NAME, 2); 
                request.onerror = (event) => reject("Database error: " + event.target.error);
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("Database opened successfully (v2)");
                     getLastHistoryEntryContent().then(content => {
                         lastSavedHistoryContent = content;
                     }).catch(err => console.error("Error getting initial last history entry:", err));
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    console.log("Database upgrade needed");
                    const tempDb = event.target.result;
                    if (!tempDb.objectStoreNames.contains(SAVED_STORE_NAME)) {
                        const savedStore = tempDb.createObjectStore(SAVED_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        savedStore.createIndex('name', 'name', { unique: false });
                        savedStore.createIndex('timestamp', 'timestamp', { unique: false });
                        console.log("Object store 'savedMarkdown' created");
                    }
                    if (!tempDb.objectStoreNames.contains(HISTORY_STORE_NAME)) {
                        const historyStore = tempDb.createObjectStore(HISTORY_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        historyStore.createIndex('timestamp', 'timestamp', { unique: false });
                        console.log("Object store 'editHistory' created");
                    }
                };
            });
        }
        async function saveMarkdown(name, content) { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const timestamp = new Date();
                const request = store.add({ name, content, timestamp });
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result); 
                    request.onerror = (event) => reject("Error saving: " + event.target.error);
                    transaction.onerror = (event) => reject("Save transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`保存失败: ${error}`); throw error; }
        }
        async function updateMarkdown(id, name, content) { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const timestamp = new Date();
                const request = store.put({ id, name, content, timestamp });
                 return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(id);
                    request.onerror = (event) => reject("Error updating: " + event.target.error);
                    transaction.onerror = (event) => reject("Update transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`更新失败: ${error}`); throw error; }
        }
        async function loadAllMarkdown() { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readonly');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const index = store.index('timestamp');
                const request = index.getAll();
                 return new Promise((resolve, reject) => {
                     request.onsuccess = () => {
                         const sortedResults = request.result.sort((a, b) => b.timestamp - a.timestamp);
                         resolve(sortedResults);
                     };
                     request.onerror = (event) => reject("Error loading all: " + event.target.error);
                     transaction.onerror = (event) => reject("Load all transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`加载列表失败: ${error}`); return []; }
        }
        async function loadMarkdownById(id) { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readonly');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const request = store.get(id);
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject("Error loading by ID: " + event.target.error);
                     transaction.onerror = (event) => reject("Load ID transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`加载文档失败: ${error}`); return null; }
        }
        async function deleteMarkdownById(id) { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([SAVED_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(SAVED_STORE_NAME);
                const request = store.delete(id);
                 return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => reject("Error deleting: " + event.target.error);
                     transaction.onerror = (event) => reject("Delete transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`删除失败: ${error}`); return false; }
        }

        // --- EDIT HISTORY Logic ---
        function scheduleHistorySave() { clearTimeout(historySaveTimeout); historySaveTimeout = setTimeout(saveCurrentStateToHistory, 2000); }
        function triggerHistorySave() { clearTimeout(historySaveTimeout); setTimeout(saveCurrentStateToHistory, 0); }
        async function saveCurrentStateToHistory() {
            const content = editor.value;
            if (content === sampleContent) return;
            if (!content.trim() || content === lastSavedHistoryContent) return;
            try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const request = store.add({ content, timestamp: new Date() });
                request.onsuccess = (e) => {
                    lastSavedHistoryContent = content; 
                    pruneHistory();
                };
                request.onerror = (event) => console.error("Error saving history entry:", event.target.error);
                transaction.onerror = (event) => console.error("History save transaction error:", event.target.error);
            } catch (error) { console.error("Failed to initiate history save:", error); }
        }
        async function pruneHistory() { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const countRequest = store.count();
                countRequest.onsuccess = () => {
                    const count = countRequest.result;
                    if (count > HISTORY_LIMIT) {
                        const itemsToDelete = count - HISTORY_LIMIT;
                        let deletedCount = 0;
                        const index = store.index('timestamp'); 
                        const cursorRequest = index.openCursor(null, 'next'); 
                        cursorRequest.onsuccess = (event) => {
                            const cursor = event.target.result;
                            if (cursor && deletedCount < itemsToDelete) {
                                cursor.delete(); 
                                deletedCount++; 
                                cursor.continue();
                            } else { 
                                if (deletedCount > 0) console.log(`Pruning complete. Deleted ${deletedCount} entries.`);
                            }
                        };
                        cursorRequest.onerror = (event) => console.error("Error opening cursor for pruning:", event.target.error);
                    }
                };
                countRequest.onerror = (event) => console.error("Error counting history items:", event.target.error);
                 transaction.onerror = (event) => console.error("History prune transaction error:", event.target.error);
            } catch (error) { console.error("Failed to initiate history pruning:", error); }
        }
        async function loadAllHistory() { 
            try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readonly');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const index = store.index('timestamp');
                const request = index.getAll();
                return new Promise((resolve, reject) => {
                     request.onsuccess = () => {
                         const sortedResults = request.result.sort((a, b) => b.timestamp - a.timestamp); 
                         resolve(sortedResults);
                     };
                     request.onerror = (event) => reject("Error loading history: " + event.target.error);
                     transaction.onerror = (event) => reject("Load history transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`加载历史失败: ${error}`); return []; }
        }
        async function loadHistoryById(id) { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readonly');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const request = store.get(id);
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject("Error loading history ID: " + event.target.error);
                     transaction.onerror = (event) => reject("Load history ID transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`加载历史条目失败: ${error}`); return null; }
        }
        async function deleteHistoryById(id) { 
             try {
                const dbInstance = await initDB();
                const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(HISTORY_STORE_NAME);
                const request = store.delete(id);
                 return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(true);
                    request.onerror = (event) => reject("Error deleting history: " + event.target.error);
                     transaction.onerror = (event) => reject("Delete history transaction error: " + event.target.error);
                });
            } catch (error) { showToast(`删除历史失败: ${error}`); return false; }
        }
         async function getLastHistoryEntryContent() { 
             return new Promise(async (resolve, reject) => {
                 try {
                    const dbInstance = await initDB();
                    const transaction = dbInstance.transaction([HISTORY_STORE_NAME], 'readonly');
                    const store = transaction.objectStore(HISTORY_STORE_NAME);
                    const index = store.index('timestamp');
                    const cursorRequest = index.openCursor(null, 'prev'); 
                    cursorRequest.onsuccess = (event) => {
                        const cursor = event.target.result;
                        resolve(cursor ? cursor.value.content : null);
                    };
                    cursorRequest.onerror = (event) => reject("Error getting last history entry: " + event.target.error);
                    transaction.onerror = (event) => reject("Last history transaction error: " + event.target.error);
                 } catch (error) { reject("Failed to initiate get last history: " + error); }
             });
         }


        // --- Diff Tracking Logic (USING JSDIFF) ---
        function loadDiffSettings() {
            isDiffTrackingEnabled = localStorage.getItem('diffTrackingEnabled') === 'true';
            diffDebounceTime = parseInt(localStorage.getItem('diffDebounceTime'), 10) || 1500;
            if (diffDebounceTime < 1000) diffDebounceTime = 1000;
            diffMatchThreshold = parseFloat(localStorage.getItem('diffMatchThreshold')) || 0.85; 
            if (diffMatchThreshold < 0.5) diffMatchThreshold = 0.5;
            if (diffMatchThreshold > 1.0) diffMatchThreshold = 1.0;

            diffTrackingToggle.checked = isDiffTrackingEnabled;
            diffDebounceTimeInput.value = diffDebounceTime;
            diffMatchThresholdInput.value = Math.round(diffMatchThreshold * 100); 
            diffMatchThresholdRange.value = Math.round(diffMatchThreshold * 100); 
            updateDiffStatusIndicator();
        }

        function saveDiffSettings() {
            localStorage.setItem('diffTrackingEnabled', isDiffTrackingEnabled);
            localStorage.setItem('diffDebounceTime', diffDebounceTime);
            localStorage.setItem('diffMatchThreshold', diffMatchThreshold); 
        }

        function updateDiffStatusIndicator() {
            if (isDiffTrackingEnabled) {
                diffStatusIndicator.textContent = '追踪开启';
                diffStatusIndicator.classList.remove('disabled');
                diffStatusIndicator.classList.add('enabled');
            } else {
                diffStatusIndicator.textContent = '追踪关闭';
                diffStatusIndicator.classList.remove('enabled');
                diffStatusIndicator.classList.add('disabled');
                isContentConsideredSameAsActiveDoc = false; 
            }
            updateActiveDocIndicatorText(); 
        }

        diffTrackingToggle.addEventListener('change', (event) => {
            isDiffTrackingEnabled = event.target.checked;
            saveDiffSettings();
            updateDiffStatusIndicator();
            showToast(`Diff内容追踪已${isDiffTrackingEnabled ? '开启' : '关闭'}`);
            if (isDiffTrackingEnabled && activeSavedDocument.id) {
                handleContentChangeForDiff(); 
            } else {
                isContentConsideredSameAsActiveDoc = false; 
                updateActiveDocIndicatorText();
            }
        });

        function showDiffConfigModal() {
            diffDebounceTimeInput.value = diffDebounceTime;
            const thresholdPercent = Math.round(diffMatchThreshold * 100);
            diffMatchThresholdInput.value = thresholdPercent;
            diffMatchThresholdRange.value = thresholdPercent;
            diffConfigModal.style.display = 'block';
        }
        function hideDiffConfigModal() { diffConfigModal.style.display = 'none'; }

        diffMatchThresholdRange.addEventListener('input', (e) => {
            diffMatchThresholdInput.value = e.target.value;
        });
        diffMatchThresholdInput.addEventListener('input', (e) => {
            let val = parseInt(e.target.value, 10);
            if (val < 50) val = 50;
            if (val > 100) val = 100;
            e.target.value = val; 
            diffMatchThresholdRange.value = val;
        });


        function handleSaveDiffSettings() {
            const newDebounceTime = parseInt(diffDebounceTimeInput.value, 10);
            if (newDebounceTime >= 1000) {
                diffDebounceTime = newDebounceTime;
            } else {
                showToast("防抖时间不能小于1000毫秒", 3000);
                diffDebounceTimeInput.value = diffDebounceTime; 
                return;
            }

            const newThresholdPercent = parseInt(diffMatchThresholdInput.value, 10);
            if (newThresholdPercent >= 50 && newThresholdPercent <= 100) {
                diffMatchThreshold = newThresholdPercent / 100; 
            } else {
                showToast("匹配阈值必须在50%到100%之间", 3000);
                diffMatchThresholdInput.value = Math.round(diffMatchThreshold * 100); 
                diffMatchThresholdRange.value = Math.round(diffMatchThreshold * 100);
                return;
            }

            saveDiffSettings();
            hideDiffConfigModal();
            showToast("Diff配置已保存！");
            if (isDiffTrackingEnabled && activeSavedDocument.id) {
                 handleContentChangeForDiff(); 
            }
        }

        function isOriginalContentSufficientlyRetained(originalText, currentText, threshold) {
            if (!originalText || originalText.length === 0) {
                return (!currentText || currentText.length === 0); 
            }
            if (originalText === currentText) return true;
            if (!currentText || currentText.length === 0) return false; 

            if (!jsdiffInstance) {
                console.warn("jsdiff library (Diff) not available for calculation.");
                showToast("警告: Diff库异常，追踪判断可能不准确。", 3000);
                return (originalText === currentText);
            }

            const diffs = jsdiffInstance.diffChars(originalText, currentText);
            let commonCharsFromOriginal = 0; 

            diffs.forEach(part => {
                if (!part.added && !part.removed) { 
                    commonCharsFromOriginal += part.value.length;
                }
            });
            
            const retentionRate = commonCharsFromOriginal / originalText.length;
            return retentionRate >= threshold;
        }


        function handleContentChangeForDiff() {
            if (!isDiffTrackingEnabled || !activeSavedDocument.id || activeSavedDocument.originalContent === null) {
                isContentConsideredSameAsActiveDoc = false; 
                updateActiveDocIndicatorText();
                return;
            }

            clearTimeout(diffDebounceTimeout);
            diffDebounceTimeout = setTimeout(() => {
                const currentContent = editor.value;
                isContentConsideredSameAsActiveDoc = isOriginalContentSufficientlyRetained(
                    activeSavedDocument.originalContent,
                    currentContent,
                    diffMatchThreshold 
                );
                updateActiveDocIndicatorText();
            }, diffDebounceTime);
        }

        // --- Active Saved Document State ---
        function setActiveSavedDocumentState(id, name, content) {
            activeSavedDocument.id = id;
            activeSavedDocument.name = name;
            activeSavedDocument.originalContent = content; 
            isContentConsideredSameAsActiveDoc = true; 
            updateActiveDocIndicatorText();
            console.log(`Active document set: ID ${id}, Name "${name}"`);
        }

        function clearActiveSavedDocumentState(isDestructiveLoad = false) {
            if (activeSavedDocument.id !== null) {
                 console.log(`Active document cleared. Was: ID ${activeSavedDocument.id}, Name "${activeSavedDocument.name}"`);
            }
            activeSavedDocument.id = null;
            activeSavedDocument.name = null;
            activeSavedDocument.originalContent = null;
            isContentConsideredSameAsActiveDoc = false;
            updateActiveDocIndicatorText();
        }
        
        function updateActiveDocIndicatorText() {
            if (activeSavedDocument.id && activeSavedDocument.name) {
                let indicatorText = escapeHtml(activeSavedDocument.name);
                let titleText = `当前内容基于已保存的文档: ${escapeHtml(activeSavedDocument.name)}`;

                if (isDiffTrackingEnabled) { 
                    if (editor.value === activeSavedDocument.originalContent) {
                        // Identical
                    } else if (isContentConsideredSameAsActiveDoc) {
                        indicatorText += " (追踪中)"; 
                        titleText += " (内容已修改，但仍在追踪范围内)";
                    } else {
                        indicatorText += " (差异较大)"; 
                        titleText += " (内容差异较大，已不视为追踪同一文档)";
                    }
                } else { 
                    if (activeSavedDocument.originalContent !== null && editor.value !== activeSavedDocument.originalContent) {
                         indicatorText += "*"; 
                         titleText += " (已修改)";
                    }
                }
                activeDocIndicatorEl.textContent = indicatorText;
                activeDocIndicatorEl.title = titleText;

            } else {
                activeDocIndicatorEl.textContent = '';
                activeDocIndicatorEl.title = '';
            }
        }


        // --- UI Interaction for Modals ---
        function showLoadModal() { populateModal(false); }
        function showSaveModal() { populateModal(true); }
        function hideLoadModal() { loadModal.style.display = 'none'; }

        async function populateModal(isSavingMode = false) {
            modalTitle.textContent = isSavingMode ? "保存或更新 Markdown" : "加载已保存的 Markdown";
            saveNewButton.style.display = isSavingMode ? 'inline-flex' : 'none';
            searchInput.value = '';
            try {
                const items = await loadAllMarkdown();
                savedItemList.innerHTML = ''; 
                const noItemsLi = '<li class="no-items">没有找到已保存的文档。</li>';

                if (items && items.length > 0) {
                    let activeItemElement = null;
                    items.forEach(item => {
                        const li = document.createElement('li');
                        li.className = 'saved-item';
                        li.dataset.id = item.id; li.dataset.name = item.name;
                        li.innerHTML = `
                            <div class="item-info">
                                <span class="item-name" title="${escapeHtml(item.name)}">${escapeHtml(item.name)}</span>
                                <span class="item-timestamp">保存于: ${formatTimestamp(item.timestamp)}</span>
                            </div>
                            <div class="item-actions">
                                ${isSavingMode ? `<button class="small" onclick="handleUpdateItem(event, ${item.id})" title="使用当前编辑器内容覆盖此项">更新</button>` : ''}
                                <button class="small" onclick="handleLoadItem(${item.id})" title="加载此项到编辑器">加载</button>
                                <button class="small danger" onclick="handleDeleteItem(event, ${item.id}, 'saved')" title="删除此项">删除</button>
                            </div>`;
                        savedItemList.appendChild(li);

                        if (isSavingMode && isDiffTrackingEnabled && isContentConsideredSameAsActiveDoc &&
                            activeSavedDocument.id === item.id) {
                            li.classList.add('highlighted-active-doc');
                            activeItemElement = li;
                        }
                    });
                    
                    if (activeItemElement) {
                        loadModal.style.display = 'block'; 
                        requestAnimationFrame(() => { 
                             activeItemElement.scrollIntoView({ behavior: 'auto', block: 'center', inline: 'nearest' });
                        });
                    } else {
                         loadModal.style.display = 'block';
                    }
                } else {
                    savedItemList.innerHTML = noItemsLi;
                    loadModal.style.display = 'block';
                }
                filterSavedItems();
            } catch (error) {
                showToast(`加载列表失败: ${error}`);
                savedItemList.innerHTML = '<li class="no-items" style="color:red;">加载列表时出错。</li>';
                loadModal.style.display = 'block';
            }
        }
        function filterSavedItems() { 
            const filter = searchInput.value.toLowerCase();
            const items = savedItemList.querySelectorAll('li.saved-item');
            let visibleCount = 0;
            const noItemsMessage = savedItemList.querySelector('.no-items') || document.createElement('li');
            noItemsMessage.className = 'no-items';
            noItemsMessage.textContent = filter ? '没有匹配的文档。' : '没有找到已保存的文档。';
            items.forEach(item => {
                const name = item.dataset.name ? item.dataset.name.toLowerCase() : '';
                if (name.includes(filter)) { item.style.display = 'flex'; visibleCount++; }
                else { item.style.display = 'none'; }
            });
             if (visibleCount === 0 && items.length > 0) { if (!savedItemList.contains(noItemsMessage)) savedItemList.appendChild(noItemsMessage); noItemsMessage.style.display = 'block'; }
             else if (visibleCount > 0) { if (savedItemList.contains(noItemsMessage)) noItemsMessage.style.display = 'none'; }
             else if (items.length === 0) { if (!savedItemList.contains(noItemsMessage)) { savedItemList.innerHTML = ''; savedItemList.appendChild(noItemsMessage); } noItemsMessage.style.display = 'block'; }
        }
        function showHistoryModal() { populateHistoryModal(); }
        function hideHistoryModal() { historyModal.style.display = 'none'; }
        async function populateHistoryModal() { 
             try {
                const items = await loadAllHistory();
                historyItemList.innerHTML = '';
                const noItemsLi = '<li class="no-items">没有编辑历史记录。</li>';
                if (items && items.length > 0) {
                    items.forEach(item => {
                        const li = document.createElement('li');
                        li.className = 'history-item';
                        li.dataset.id = item.id;
                        const previewText = item.content.substring(0, 60).replace(/\n/g, ' ') + (item.content.length > 60 ? '...' : '');
                        li.innerHTML = `
                            <div class="item-info">
                                <span class="item-timestamp">记录于: ${formatTimestamp(item.timestamp)}</span>
                                <span class="item-content-preview" title="${escapeHtml(item.content.substring(0, 200))}">${escapeHtml(previewText)}</span>
                            </div>
                            <div class="item-actions">
                                <button class="small primary" onclick="handleRestoreHistory(${item.id})" title="恢复此版本到编辑器">恢复</button>
                                <button class="small danger" onclick="handleDeleteItem(event, ${item.id}, 'history')" title="删除此历史记录">删除</button>
                            </div>`;
                        historyItemList.appendChild(li);
                    });
                } else { historyItemList.innerHTML = noItemsLi; }
                 historyModal.style.display = 'block';
            } catch (error) {
                showToast(`加载历史列表失败: ${error}`);
                historyItemList.innerHTML = '<li class="no-items" style="color:red;">加载历史列表时出错。</li>';
                historyModal.style.display = 'block';
            }
        }

        // --- Action Handlers ---
        async function handleSaveNew() { 
            const content = editor.value;
            if (!content.trim()) { showToast("编辑器内容为空，无法保存。"); return; }
            const defaultName = `Markdown ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`;
            const name = prompt("请输入新文档的名称:", defaultName);
            if (name === null || name.trim() === "") { showToast("已取消保存或名称无效。"); return; }
            try {
                const newId = await saveMarkdown(name.trim(), content); 
                showToast(`"${name.trim()}" 已成功保存！`);
                if (newId) setActiveSavedDocumentState(newId, name.trim(), content);
                else clearActiveSavedDocumentState(); 
                hideLoadModal();
            }
            catch (error) { console.error("Save new failed:", error); }
        }
        async function handleUpdateItem(event, id) { 
            event.stopPropagation();
            const content = editor.value;
            if (!content.trim()) { showToast("编辑器内容为空，无法更新。"); return; }
            try {
                const itemToUpdate = await loadMarkdownById(id);
                if (!itemToUpdate) { showToast("找不到要更新的项目。"); populateModal(true); return; }
                if (confirm(`确定要用当前编辑器内容覆盖 "${itemToUpdate.name}" 吗？`)) {
                    const newName = prompt("请输入更新后的名称（留空则保留原名）:", itemToUpdate.name);
                     if (newName === null) { showToast("更新已取消。"); return; }
                    const finalName = (newName.trim() === "") ? itemToUpdate.name : newName.trim();
                    await updateMarkdown(id, finalName, content);
                    showToast(`"${finalName}" 已成功更新！`);
                    setActiveSavedDocumentState(id, finalName, content);
                    hideLoadModal();
                } else { showToast("更新已取消。"); }
            } catch (error) { console.error("Update failed:", error); }
        }
        async function handleLoadItem(id) { 
             try {
                 const item = await loadMarkdownById(id);
                 if (item) {
                     editor.value = item.content;
                     updatePreview();
                     setActiveSavedDocumentState(item.id, item.name, item.content);
                     hideLoadModal(); editor.scrollTop = 0;
					 showToast(`已加载: ${item.name}`);
                     triggerHistorySave(); 
                 } else { showToast("无法找到该项目。"); }
             } catch (error) { console.error("Load item failed:", error); }
        }
        async function handleRestoreHistory(id) { 
             try {
                 const item = await loadHistoryById(id);
                 if (item) {
                     editor.value = item.content;
                     updatePreview();
                     hideHistoryModal(); editor.scrollTop = 0;
					 showToast(`已从 ${formatTimestamp(item.timestamp)} 恢复`);
                     lastSavedHistoryContent = item.content;
                     clearActiveSavedDocumentState(true); 
                 } else { showToast("无法找到该历史记录。"); }
             } catch (error) { console.error("Restore history failed:", error); }
        }
        async function handleDeleteItem(event, id, type) { 
             event.stopPropagation();
             const listElement = (type === 'saved') ? savedItemList : historyItemList;
             const itemElement = listElement.querySelector(`li[data-id='${id}']`);
             const itemName = (type === 'saved' && itemElement) ? itemElement.dataset.name : `此${type === 'saved' ? '文档' : '历史记录'}`;
             const deleteFunction = (type === 'saved') ? deleteMarkdownById : deleteHistoryById;

             if (confirm(`确定要删除 "${itemName}" 吗？此操作无法撤销。`)) {
                 try {
                     const success = await deleteFunction(id);
                     if (success) {
                        if (itemElement) {
                            itemElement.style.transition = 'opacity 0.3s ease-out, height 0.3s ease-out, margin 0.3s ease-out, padding 0.3s ease-out, border 0.3s ease-out';
                            itemElement.style.opacity = '0'; itemElement.style.height = '0'; itemElement.style.margin = '0'; itemElement.style.padding = '0'; itemElement.style.border = 'none';
                            setTimeout(() => {
                                if (itemElement.parentNode) itemElement.remove();
                                if (type === 'saved') {
                                    filterSavedItems();
                                    if (activeSavedDocument.id === id) clearActiveSavedDocumentState(true);
                                }
                                else { if (historyItemList.querySelectorAll('.history-item').length === 0) { historyItemList.innerHTML = '<li class="no-items">没有编辑历史记录。</li>'; } }
                            }, 300);
                        }
                        showToast(`"${itemName}" 已删除。`);
                     } else { showToast(`删除 "${itemName}" 失败。`); }
                 } catch (error) { console.error(`Delete ${type} failed:`, error); }
             }
        }

        // Close modals on outside click or Escape key
        window.onclick = function(event) { 
            if (event.target == loadModal) hideLoadModal();
            if (event.target == historyModal) hideHistoryModal();
            if (event.target == diffConfigModal) hideDiffConfigModal();
        }
        window.addEventListener('keydown', function(event) { 
            if (event.key === 'Escape') {
                if (loadModal.style.display === 'block') hideLoadModal();
                if (historyModal.style.display === 'block') hideHistoryModal();
                if (diffConfigModal.style.display === 'block') hideDiffConfigModal();
            }
        });


        // --- Utility Functions ---
        function escapeHtml(unsafe) { 
            if (typeof unsafe !== 'string') return '';
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
         }
         function formatTimestamp(date) { 
             if (!(date instanceof Date)) date = new Date(date);
             if (isNaN(date)) return "Invalid Date";
             try { return date.toLocaleString('zh-CN', { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' }); }
             catch (e) { console.error("Error formatting date:", e); return "Error Date"; }
        }
        function sanitizeFilenameComponent(name) { 
            if (!name || typeof name !== 'string') return '';
            return name.trim().toLowerCase().replace(/\s+/g, '-').replace(/[^\w.-]/g, '').substring(0, 50);
        }
        function getTimestampForFilename() { 
            const now = new Date();
            return `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}-${now.getHours().toString().padStart(2, '0')}${now.getMinutes().toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
        }
        
        function generateBaseFilename() { 
            let baseName = '';
            if (isDiffTrackingEnabled && isContentConsideredSameAsActiveDoc && activeSavedDocument.id && activeSavedDocument.name) {
                baseName = sanitizeFilenameComponent(activeSavedDocument.name);
            }

            if (!baseName) { 
                const content = editor.value.trim();
                const h1Match = content.match(/^#\s+(.*)/m);
                if (h1Match && h1Match[1]) {
                    baseName = sanitizeFilenameComponent(h1Match[1]);
                } else {
                    const firstLine = content.split('\n')[0];
                    if (firstLine) {
                        baseName = sanitizeFilenameComponent(firstLine.substring(0,50)); 
                    }
                }
            }
            if (!baseName || baseName.length === 0) baseName = 'markdown-export';
            return `${baseName}-${getTimestampForFilename()}`;
        }


        // --- Scroll Sync ---
		function syncScroll(source, target) { 
			if (isSyncing) return; isSyncing = true;
			const ratio = source.scrollTop / (source.scrollHeight - source.clientHeight || 1);
			target.scrollTop = ratio * (target.scrollHeight - target.clientHeight);
			requestAnimationFrame(() => { isSyncing = false; });
		}
		editor.addEventListener('scroll', () => syncScroll(editor, preview));
		preview.addEventListener('scroll', () => syncScroll(preview, editor));

        // --- Initialization ---
        editor.addEventListener('input', () => {
            updatePreview();
            scheduleHistorySave();
            handleContentChangeForDiff(); 
        });
        editor.addEventListener('paste', () => {
            setTimeout(() => {
                updatePreview();
                triggerHistorySave();
                handleContentChangeForDiff(); 
            }, 0);
        });
        editor.addEventListener('blur', () => {
             clearTimeout(historySaveTimeout);
             saveCurrentStateToHistory(); 
        });


        loadSample();
        initDB().then(() => {
            console.log("DB Initialized.");
            pruneHistory();
            loadDiffSettings(); 

            if (typeof Diff === 'undefined') { 
                console.error("jsdiff library (Diff) not loaded!");
                showToast("错误：Diff库未加载，追踪功能将不可用。", 5000);
                isDiffTrackingEnabled = false;
                diffTrackingToggle.checked = false;
                diffTrackingToggle.disabled = true;
                const diffConfigButton = document.querySelector('button[onclick="showDiffConfigModal()"]');
                if (diffConfigButton) diffConfigButton.disabled = true;
                updateDiffStatusIndicator();
                jsdiffInstance = null; 
            } else {
                jsdiffInstance = Diff; 
                console.log("jsdiff (Diff) instance ready.");
            }
        }).catch(err => console.error("Initial DB connection failed:", err));

    </script>
</body>
</html>